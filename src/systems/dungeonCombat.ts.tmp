import type React from 'react';
import type { 
  Dungeon, 
  RoutePull, 
  DungeonRunResult, 
  EnemyPack, 
  CombatLogEntry 
} from '../types/dungeon';
import type { 
  Character 
} from '../types/character';
import type { 
  CombatState, 
  CombatRef, 
  AnimatedEnemy, 
  FloatingNumber, 
  TeamMemberState,
  PlayerAbility
} from '../types/combat';
import { 
  getEnemyById 
} from '../types/dungeon';
import { 
  calculateArmorReduction, 
  calculateEvasionChance,
  rollBlock,
  rollSpellBlock,
  rollSpellSuppression,
  BLOCK_DAMAGE_REDUCTION,
  SPELL_SUPPRESSION_DAMAGE_REDUCTION,
  calculateDamageWithResistances
} from '../types/character';
import { 
  initTeamStates, 
  initAbilities, 
  createFloatingNumber, 
  getEnemyBehavior 
} from '../utils/combat';
import { 
  generateDungeonLoot, 
  generateOrbDrops 
} from './crafting';
import { 
  getSkillGemById, 
  getSupportGemById,
  calculateCriticalStrikeChance,
  getSkillIdFromAbilityName
} from '../types/skills';
import { 
  calculatePassiveBonuses 
} from '../types/passives';
import { 
  calculateExperienceFromEnemy 
} from '../utils/leveling';

const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

export interface DungeonCombatCallbacks {
  setCombatState: (updater: (prev: CombatState) => CombatState) => void;
  setIsRunning: (running: boolean) => void;
  setRunResult: (result: DungeonRunResult | null) => void;
  setIsPaused: (paused: boolean) => void;
  setScreenShake: (updater: (prev: number) => number) => void;
  setTeamFightAnim: (updater: (prev: number) => number) => void;
  setEnemyFightAnims: (updater: (prev: Record<string, number>) => Record<string, number>) => void;
  addOrbs: (orbs: Record<string, number>) => void;
  completeDungeonRun: (result: DungeonRunResult) => void;
  addKey: (key: { id: string; dungeonId: string; level: number; affixes: any[]; depleted: boolean }) => void;
  awardExperience: (characterId: string, experience: number) => { leveledUp: boolean; newLevel: number; levelsGained: number } | null;
}

export interface DungeonCombatParams {
  team: Character[];
  dungeon: Dungeon;
  routePulls: RoutePull[];
  selectedKeyLevel: number;
  scaling: ReturnType<typeof import('../types/dungeon').calculateKeyScaling>;
  combatRef: React.MutableRefObject<CombatRef>;
  combatState: CombatState;
  shieldActive: boolean;
  stunActive: boolean;
  callbacks: DungeonCombatCallbacks;
}

export async function runDungeonCombat(params: DungeonCombatParams): Promise<DungeonRunResult | null> {
  const {
    team,
    dungeon,
    routePulls,
    selectedKeyLevel,
    scaling,
    combatRef,
    combatState: initialCombatState,
    shieldActive,
    stunActive,
    callbacks
  } = params;

  const {
    setCombatState,
    setIsRunning,
    setRunResult,
    setIsPaused,
    setScreenShake,
    setTeamFightAnim,
    setEnemyFightAnims,
    addOrbs,
    completeDungeonRun,
    addKey,
    awardExperience
  } = callbacks;
  
  // Track which enemies have already awarded experience (to avoid double-awarding)
  const experienceAwarded = new Set<string>();

  setIsRunning(true);
  setRunResult(null);
  setIsPaused(false);
  combatRef.current.stop = false;
  combatRef.current.paused = false;
  
  const initialTeamStates = initTeamStates(team);
  const initialAbilities = initAbilities();
  
  setCombatState({
    phase: 'traveling',
    currentPullIndex: 0,
    teamPosition: { x: 100, y: 400 },
    enemies: [],
    teamStates: initialTeamStates,
    combatLog: [{ timestamp: 0, type: 'phase', source: '', target: '', message: `‚öîÔ∏è ${dungeon.name} +${selectedKeyLevel} STARTED!` }],
    forcesCleared: 0,
    timeElapsed: 0,
    killedGateBosses: new Set(),
    abilities: initialAbilities,
    bloodlustActive: false,
    bloodlustTimer: 0,
    floatingNumbers: [],
    levelUpAnimations: []
  });
  
  // Track healer ability cooldowns
  const healerCooldowns = { painSuppression: 0 };
  
  // Track tank ability cooldowns
  const tankCooldowns = { shieldSlam: 0, defensiveStance: 0, shieldBlock: 0 };

  let totalForcesCleared = 0;
  let totalTime = 0;
  let currentPos = { x: 100, y: 400 };
  let teamStates = [...initialTeamStates];
  let abilities = [...initialAbilities];
  let bloodlustActive = false;
  let bloodlustTimer = 0;
  let timedOut = false;
  let currentCombatState = { ...initialCombatState, teamStates: initialTeamStates, timeElapsed: 0 };

  // Helper to check timeout
  const checkTimeout = () => {
    if (totalTime >= dungeon.timeLimitSeconds) {
      timedOut = true;
      return true;
    }
    return false;
  };

  // Helper to update combat state (syncs local state)
  const updateCombatState = (updater: (prev: CombatState) => CombatState) => {
    currentCombatState = updater(currentCombatState);
    setCombatState(() => currentCombatState);
  };

  for (let pullIdx = 0; pullIdx < routePulls.length; pullIdx++) {
    if (combatRef.current.stop || timedOut) break;
    
    const pull = routePulls[pullIdx];
    const packs = pull.packIds.map(id => dungeon.enemyPacks.find(p => p.id === id)).filter(Boolean) as EnemyPack[];
    if (packs.length === 0) continue;

    const targetX = packs.reduce((sum, p) => sum + p.position.x, 0) / packs.length;
    const targetY = packs.reduce((sum, p) => sum + p.position.y, 0) / packs.length;

    // Calculate travel time based on distance (faster movement, but still takes time)
    const distance = Math.sqrt(Math.pow(targetX - currentPos.x, 2) + Math.pow(targetY - currentPos.y, 2));
    const travelTime = Math.max(1.5, Math.min(5, distance / 200)); // 1.5-5 seconds based on distance
    const travelSteps = 60; // Smooth 60fps-like animation

    // Travel
    updateCombatState(prev => ({ ...prev, phase: 'traveling', currentPullIndex: pullIdx, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'travel', source: '', target: '', message: `üö∂ Moving to Pull #${pullIdx + 1}... (${travelTime.toFixed(1)}s)` }] }));

    for (let i = 1; i <= travelSteps; i++) {
      if (combatRef.current.stop || checkTimeout()) break;
      await sleep((travelTime * 1000) / travelSteps);
      totalTime += travelTime / travelSteps;
      // Use easing for smoother movement (ease-out)
      const progress = i / travelSteps;
      const eased = 1 - Math.pow(1 - progress, 2);
      const newX = currentPos.x + (targetX - currentPos.x) * eased;
      const newY = currentPos.y + (targetY - currentPos.y) * eased;
      updateCombatState(prev => ({ ...prev, teamPosition: { x: newX, y: newY }, timeElapsed: totalTime }));
    }
    
    // Check if stopped during travel
    if (combatRef.current.stop) {
      setIsRunning(false);
      return null;
    }
    
    currentPos = { x: targetX, y: targetY };
    
    if (timedOut) {
      updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: '‚è∞ TIME EXPIRED! Dungeon failed.' }] }));
      break;
    }

    // Create enemies
    const pullEnemies: AnimatedEnemy[] = [];
    packs.forEach(pack => {
      pack.enemies.forEach(({ enemyId, count }) => {
        const enemyDef = getEnemyById(enemyId);
        if (!enemyDef) return;
        for (let i = 0; i < count; i++) {
          pullEnemies.push({
            id: `${enemyId}_${pullIdx}_${i}_${Math.random()}`,
            enemyId,
            name: enemyDef.name,
            icon: enemyDef.icon,
            type: enemyDef.type,
            behavior: getEnemyBehavior(enemyId),
            health: enemyDef.baseHealth * scaling.healthMultiplier,
            maxHealth: enemyDef.baseHealth * scaling.healthMultiplier,
            damage: enemyDef.baseDamage * scaling.damageMultiplier * 0.2 * 2 * 2, // double enemy damage again
            isCasting: false,
            castProgress: 0,
            gcdRemaining: 0,
            aoeCooldown: 0,
            autoAttackTimer: Math.random() * 0.6 + 0.1 // staggered start for autos
          });
        }
      });
    });

    const hasGateBoss = packs.some(p => p.isGateBoss);
    updateCombatState(prev => ({
      ...prev, phase: 'combat', enemies: pullEnemies, teamStates,
      combatLog: [...prev.combatLog, { timestamp: totalTime, type: hasGateBoss ? 'boss' : 'pull', source: '', target: '', message: hasGateBoss ? `üëë GATE BOSS: ${pullEnemies.length} enemies!` : `‚öîÔ∏è PULL #${pullIdx + 1}: ${pullEnemies.length} enemies!` }]
    }));

    // Combat loop - 1 second ticks, each entity acts when their GCD is ready
    let currentEnemies = [...pullEnemies];
    
    while (currentEnemies.some(e => e.health > 0) && teamStates.some(m => !m.isDead) && !timedOut) {
      if (combatRef.current.stop) break;
      
      // Pause check - wait while paused
      while (combatRef.current.paused && !combatRef.current.stop) {
        await sleep(100);
      }
      if (combatRef.current.stop) break;

      if (checkTimeout()) {
        updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: '‚è∞ TIME EXPIRED! Dungeon failed.' }] }));
        break;
      }
      
      // Wait 7ms (roughly 143 ticks per second for smooth timing)
      const TICK_DURATION = 0.007; // seconds (7ms)
      await sleep(7);
      totalTime += TICK_DURATION;
      
      // Check for wipe
      if (!teamStates.some(m => !m.isDead)) {
        updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: 'üíÄ WIPE! Your party has been defeated.' }] }));
        
        // Find what killed teammates - look for recent damage entries targeting team members
        const teamMemberNames = teamStates.map(m => m.name);
        const deathCauses: Record<string, string> = {};
        const recentDamage = currentCombatState.combatLog
          .filter(entry => entry.type === 'damage' && teamMemberNames.includes(entry.target))
          .slice(-20); // Last 20 damage entries
        
        teamStates.forEach(member => {
          if (member.isDead) {
            // Find the last damage entry for this member
            const lastDamage = recentDamage
              .filter(entry => entry.target === member.name)
              .sort((a, b) => b.timestamp - a.timestamp)[0];
            if (lastDamage) {
              deathCauses[member.name] = lastDamage.source || 'Unknown';
            }
          }
        });
        
        // Generate reduced loot for wipe (scales with key level and progress made)
        const progressPercent = totalForcesCleared / dungeon.requiredForces;
        const wipeLootCount = Math.max(1, Math.floor(progressPercent * 3) + Math.floor(selectedKeyLevel / 5));
        const loot = generateDungeonLoot(selectedKeyLevel, false, 0, scaling.itemQuantity, scaling.itemRarity).slice(0, wipeLootCount);
        const orbDrops = generateOrbDrops(selectedKeyLevel, false, progressPercent);
        const xp = Math.floor(200 * scaling.rewardMultiplier * progressPercent);
        
        const result: DungeonRunResult = {
          success: false, keyLevel: selectedKeyLevel, timeElapsed: totalTime, timeLimit: dungeon.timeLimitSeconds,
          upgradeLevel: 0, loot, orbDrops, experienceGained: xp, deaths: teamStates.filter(m => m.isDead).length,
          forcesCleared: totalForcesCleared, forcesRequired: dungeon.requiredForces, combatLog: currentCombatState.combatLog,
          failReason: 'wipe',
          failedPullIndex: currentCombatState.currentPullIndex,
          deathCauses
        };
        
        addOrbs(orbDrops);
        setRunResult(result);
        setIsRunning(false);
        return result;
      }

      // Reduce ability cooldowns - 0.2 seconds per tick
      abilities = abilities.map(a => ({ ...a, currentCooldown: Math.max(0, a.currentCooldown - TICK_DURATION) }));
      if (bloodlustActive) {
        bloodlustTimer -= TICK_DURATION;
        if (bloodlustTimer <= 0) bloodlustActive = false;
      }

      const aliveEnemies = currentEnemies.filter(e => e.health > 0);
      
      if (aliveEnemies.length === 0) break;

      // Decrement all GCDs ONCE per tick (players and enemies) - 0.2s per tick
      teamStates = teamStates.map(m => ({ ...m, gcdRemaining: Math.max(0, (m.gcdRemaining || 0) - TICK_DURATION) }));
      
      // Check for resurrection requests from useAbility
      if (combatRef.current.resurrectRequest) {
        const rezTargetId = combatRef.current.resurrectRequest;
        teamStates = teamStates.map(m => 
          m.id === rezTargetId 
            ? { ...m, isDead: false, health: Math.floor(m.maxHealth * 0.6), mana: Math.floor(m.maxMana * 0.3), lastResurrectTime: Date.now() } 
            : m
        );
        combatRef.current.resurrectRequest = null;
      }
      
      // Check for bloodlust activation from useAbility
      if (combatRef.current.bloodlustRequest) {
        bloodlustActive = true;
        bloodlustTimer = 15;
        combatRef.current.bloodlustRequest = false;
      }
      
      // Sync ability cooldowns from ref (when player clicks abilities)
      Object.entries(combatRef.current.abilityCooldowns).forEach(([id, cd]) => {
        const ability = abilities.find(a => a.id === id);
        if (ability && cd > ability.currentCooldown) {
          ability.currentCooldown = cd;
        }
      });
      combatRef.current.abilityCooldowns = {};
      
      // Process buffs, HoTs, regen, and decay recent damage tracking
      teamStates = teamStates.map(m => {
        if (m.isDead) return m;
        
        // Base regeneration per second, scaled by tick duration
        // Tanks regen 1% HP/sec, others 0.5%; Healers regen 3% mana/sec, others 2%
        const hpRegenPerSecond = m.role === 'tank' ? m.maxHealth * 0.01 : m.maxHealth * 0.005;
        const manaRegenPerSecond = m.role === 'healer' ? m.maxMana * 0.03 : m.maxMana * 0.02;
        
        // Apply regeneration scaled by tick (don't exceed max)
        const hpRegenAmount = hpRegenPerSecond * TICK_DURATION;
        const manaRegenAmount = manaRegenPerSecond * TICK_DURATION;
        
        // Decay damage reduction duration (Pain Suppression) - use TICK_DURATION
        let newDmgReduction = m.damageReduction || 0;
        let newDmgReductionDuration = (m.damageReductionDuration || 0) - TICK_DURATION;
        if (newDmgReductionDuration <= 0) {
          newDmgReduction = 0;
          newDmgReductionDuration = 0;
        }
        
        // Decay armor buff duration (Defensive Stance) - use TICK_DURATION
        let newArmorBuff = m.armorBuff || 0;
        let newArmorBuffDuration = (m.armorBuffDuration || 0) - TICK_DURATION;
        if (newArmorBuffDuration <= 0) {
          newArmorBuff = 0;
          newArmorBuffDuration = 0;
        }
        
        // Decay block buff duration (Shield Block) - use TICK_DURATION
        let newBlockBuff = m.blockBuff || 0;
        let newBlockBuffDuration = (m.blockBuffDuration || 0) - TICK_DURATION;
        if (newBlockBuffDuration <= 0) {
          newBlockBuff = 0;
          newBlockBuffDuration = 0;
        }
        
        // Decay recent damage taken (scaled by tick - decay slower with faster ticks)
        const decayFactor = Math.pow(0.5, TICK_DURATION); // decay per tick at 7ms
        const newRecentDamage = Math.floor((m.recentDamageTaken || 0) * decayFactor);
        
        // Process HoT effects - start with current health + passive regen
        let newHealth = Math.min(m.maxHealth, m.health + hpRegenAmount);
        let newMana = Math.min(m.maxMana, m.mana + manaRegenAmount);
        let hotHealingBySource: Record<string, number> = {};
        let newHotEffects = (m.hotEffects || []).map(hot => {
          let updatedHot = { ...hot, remainingDuration: hot.remainingDuration - TICK_DURATION, nextTickIn: hot.nextTickIn - TICK_DURATION };
          // Tick the HoT
          if (updatedHot.nextTickIn <= 0 && updatedHot.remainingDuration > 0) {
            const healAmount = hot.healPerTick;
            // Check for critical heal on HoT tick
            const hotHealerChar = team.find(c => c.id === hot.sourceId);
            const critChance = hotHealerChar?.baseStats?.criticalStrikeChance || 10;
            const isCritHeal = Math.random() < (critChance / 100);
            const finalHealAmount = isCritHeal ? Math.floor(healAmount * 1.5) : healAmount;
            const actualHeal = Math.min(m.maxHealth - newHealth, finalHealAmount);
            newHealth = Math.min(m.maxHealth, newHealth + finalHealAmount);
            // Track healing by source
            if (hot.sourceId) {
              hotHealingBySource[hot.sourceId] = (hotHealingBySource[hot.sourceId] || 0) + actualHeal;
              // Track by spell name
              const hotHealer = teamStates.find(t => t.id === hot.sourceId);
              if (hotHealer) {
                hotHealer.healingBySpell = hotHealer.healingBySpell || {};
                hotHealer.healingBySpell[hot.name] = (hotHealer.healingBySpell[hot.name] || 0) + actualHeal;
              }
            }
            updatedHot.nextTickIn = hot.tickInterval;
            // Show heal number
            const jitterX = (Math.random() * 80) - 40;
            const jitterY = (Math.random() * 60) - 30;
            const floatNum = createFloatingNumber(finalHealAmount, 'heal', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 45 + jitterY);
            const hotHealTimestamp = Date.now();
            // Update member's lastHealTime for frame animation
            m.lastHealTime = hotHealTimestamp;
            m.lastHealAmount = actualHeal;
            m.lastHealCrit = isCritHeal;
            if (isCritHeal) setScreenShake(prev => prev + 1);
            updateCombatState(prev => ({ 
              ...prev, 
              teamStates: prev.teamStates.map(teamMember => 
                teamMember.id === m.id 
                  ? { ...teamMember, lastHealTime: hotHealTimestamp, lastHealAmount: actualHeal, lastHealCrit: isCritHeal, health: newHealth }
                  : teamMember
              ),
              floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum] 
            }));
          }
          return updatedHot;
        }).filter(hot => hot.remainingDuration > 0);
        
        // Credit HoT healing to healers
        Object.entries(hotHealingBySource).forEach(([sourceId, healing]) => {
          const healer = teamStates.find(t => t.id === sourceId);
          if (healer) {
            healer.totalHealing = (healer.totalHealing || 0) + healing;
          }
        });
        
        return { 
          ...m, 
          health: newHealth,
          mana: newMana,
          damageReduction: newDmgReduction, 
          damageReductionDuration: newDmgReductionDuration,
          armorBuff: newArmorBuff,
          armorBuffDuration: newArmorBuffDuration,
          blockBuff: newBlockBuff,
          blockBuffDuration: newBlockBuffDuration,
          recentDamageTaken: newRecentDamage,
          hotEffects: newHotEffects,
          hasRejuv: newHotEffects.some(h => h.name === 'Rejuvenation')
        };
      });
      
      // Get references AFTER the teamStates reassignment so modifications persist
      const tank = teamStates.find(m => m.role === 'tank' && !m.isDead);
      const aliveMembers = teamStates.filter(m => !m.isDead);
      
      aliveEnemies.forEach(enemy => {
        if (enemy.gcdRemaining === undefined) enemy.gcdRemaining = 0;
        if (enemy.aoeCooldown === undefined) enemy.aoeCooldown = 0;
        enemy.gcdRemaining = Math.max(0, enemy.gcdRemaining - TICK_DURATION);
        if (enemy.behavior === 'aoe') {
          enemy.aoeCooldown = Math.max(0, enemy.aoeCooldown - TICK_DURATION);
        }
        // Cast progress is now tracked via real-time (castStartTime + castTotalTime), not tick-based
      });

      // Enemy attacks - each enemy acts once per GCD / auto timer
      if (!stunActive) {
        for (const enemy of aliveEnemies) {
          if (enemy.gcdRemaining === undefined) enemy.gcdRemaining = 0;
          if (enemy.autoAttackTimer === undefined) enemy.autoAttackTimer = Math.random() * 0.6 + 0.1;

          // If casting, check if cast is complete using real-time tracking
          // Cast progress is tracked via real-time (castStartTime + castTotalTime)
          if (enemy.isCasting && enemy.castStartTime && enemy.castTotalTime) {
            const elapsedMs = Date.now() - enemy.castStartTime;
            const elapsedSeconds = elapsedMs / 1000;
            // Cast completes when elapsed time >= cast time
            if (elapsedSeconds >= enemy.castTotalTime) {
              const target = teamStates.find(m => m.id === enemy.castTarget);
              if (target && !target.isDead) {
                const effectiveArmor = target.armor * (1 + (target.armorBuff || 0) / 100);
                const painSuppMult = target.damageReduction ? (1 - target.damageReduction / 100) : 1;
                const isAuto = enemy.castAbility === 'Auto Attack';
                const isCrushingBlow = enemy.castAbility === 'Crushing Blow';
                let dmg;
                let blocked = false;
                
                if (isCrushingBlow) {
                  // Crushing Blow: 600 base damage, scaled by key level, physical (can be blocked)
                  const enemyDef = getEnemyById(enemy.enemyId);
                  const crushingBlowAbility = enemyDef?.abilities?.find(a => a.id === 'crushing_blow');
                  const baseCrushingDamage = crushingBlowAbility?.damage || 600;
                  const scaledCrushingDamage = baseCrushingDamage * scaling.damageMultiplier;
                  const rawDamage = scaledCrushingDamage * (shieldActive ? 0.5 : 1);
                  // PoE armor formula: Armor / (Armor + 10 * Damage)
                  const armorMult = calculateArmorReduction(effectiveArmor, rawDamage);
                  let damageAfterArmor = Math.floor(rawDamage * armorMult * painSuppMult);
                  const blockChance = (target.blockChance || 0) + (target.blockBuff || 0);
                  blocked = rollBlock(blockChance);
                  if (blocked) {
                    damageAfterArmor = Math.floor(damageAfterArmor * (1 - BLOCK_DAMAGE_REDUCTION));
                    target.lastBlockTime = Date.now();
                  }
                  
                  // Physical damage hits energy shield first, then life (PoE mechanic)
                  const damageResult = calculateDamageWithResistances(
                    damageAfterArmor,
                    'physical',
                    {
                      health: target.health,
                      maxHealth: target.maxHealth,
                      energyShield: target.energyShield || 0,
                      maxEnergyShield: target.maxEnergyShield || 0,
                      fireResistance: target.fireResistance || 0,
                      coldResistance: target.coldResistance || 0,
                      lightningResistance: target.lightningResistance || 0,
                      chaosResistance: target.chaosResistance || 0
                    }
                  );
                  
                  target.energyShield = Math.max(0, damageResult.esRemaining);
                  target.health = Math.max(0, damageResult.lifeRemaining);
                  dmg = damageResult.totalDamage;
                } else if (isAuto) {
                  // Physical auto: full damage, allow block and evasion
                  const rawDamage = enemy.damage * (shieldActive ? 0.5 : 1);
                  // Check evasion first (PoE: evasion happens before armor)
                  const evasionChance = target.evasion ? calculateEvasionChance(target.evasion, enemy.damage * 100) : 0;
                  if (Math.random() < evasionChance) {
                    // Attack evaded, no damage
                    dmg = 0;
                    updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: enemy.name, target: target.name, message: `üí® ${target.name} evades ${enemy.name}'s attack!` }] }));
                  } else {
                    // PoE armor formula: Armor / (Armor + 10 * Damage)
                    const armorMult = calculateArmorReduction(effectiveArmor, rawDamage);
                    let damageAfterArmor = Math.floor(rawDamage * armorMult * painSuppMult);
                    const blockChance = (target.blockChance || 0) + (target.blockBuff || 0);
                    blocked = rollBlock(blockChance);
                    if (blocked) {
                      damageAfterArmor = Math.floor(damageAfterArmor * (1 - BLOCK_DAMAGE_REDUCTION));
                      target.lastBlockTime = Date.now();
                    }
                    
                    // Physical damage hits energy shield first, then life (PoE mechanic)
                    const damageResult = calculateDamageWithResistances(
                      damageAfterArmor,
                      'physical',
                      {
                        health: target.health,
                        maxHealth: target.maxHealth,
                        energyShield: target.energyShield || 0,
                        maxEnergyShield: target.maxEnergyShield || 0,
                        fireResistance: target.fireResistance || 0,
                        coldResistance: target.coldResistance || 0,
                        lightningResistance: target.lightningResistance || 0,
                        chaosResistance: target.chaosResistance || 0
                      }
                    );
                    
                    target.energyShield = Math.max(0, damageResult.esRemaining);
                    target.health = Math.max(0, damageResult.lifeRemaining);
                    dmg = damageResult.totalDamage;
                  }
                } else {
                  // Spell hit damage (Shadow Bolt, etc.) - use ability damage if available
                  const enemyDef = getEnemyById(enemy.enemyId);
                  const ability = enemyDef?.abilities?.find(a => a.name === enemy.castAbility);
                  const abilityDamage = ability?.damage;
                  const damageType = (ability?.damageType || 'shadow') as 'physical' | 'fire' | 'cold' | 'lightning' | 'chaos' | 'shadow' | 'holy' | 'magic';
                  let rawSpellDamage: number;
                  if (abilityDamage !== undefined) {
                    // Use ability damage, scaled by key level
                    rawSpellDamage = abilityDamage * scaling.damageMultiplier;
                  } else {
                    // Fallback to old spell damage calculation
                    rawSpellDamage = enemy.damage * 0.1875;
                  }
                  rawSpellDamage *= (shieldActive ? 0.5 : 1);
                  
                  // Check spell block and spell suppression
                  const spellBlockChance = (target.spellBlockChance || 0) + (target.blockBuff || 0);
                  const spellBlocked = rollSpellBlock(spellBlockChance);
                  const spellSuppressed = target.spellSuppressionChance ? rollSpellSuppression(target.spellSuppressionChance) : false;
                  
                  if (spellBlocked) {
                    rawSpellDamage = Math.floor(rawSpellDamage * (1 - BLOCK_DAMAGE_REDUCTION));
                    target.lastBlockTime = Date.now();
                    blocked = true;
                  } else if (spellSuppressed) {
                    // Apply spell suppression (50% damage reduction)
                    rawSpellDamage = Math.floor(rawSpellDamage * (1 - SPELL_SUPPRESSION_DAMAGE_REDUCTION));
                  }
                  
                  // Apply resistances and energy shield (PoE style)
                  const damageResult = calculateDamageWithResistances(
                    rawSpellDamage,
                    damageType,
                    {
                      health: target.health,
                      maxHealth: target.maxHealth,
                      energyShield: target.energyShield || 0,
                      maxEnergyShield: target.maxEnergyShield || 0,
                      fireResistance: target.fireResistance || 0,
                      coldResistance: target.coldResistance || 0,
                      lightningResistance: target.lightningResistance || 0,
                      chaosResistance: target.chaosResistance || 0
                    }
                  );
                  
                  // Apply pain suppression multiplier
                  const finalDamageToES = Math.floor(damageResult.damageToES * painSuppMult);
                  const finalDamageToLife = Math.floor(damageResult.damageToLife * painSuppMult);
                  
                  // Update energy shield and health
                  target.energyShield = Math.max(0, (target.energyShield || 0) - finalDamageToES);
                  target.health = Math.max(0, target.health - finalDamageToLife);
                  dmg = finalDamageToES + finalDamageToLife;
                }
                target.recentDamageTaken = (target.recentDamageTaken || 0) + dmg;
                setTeamFightAnim(prev => prev + 1); // Trigger team hit animation
                setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 })); // Trigger enemy attack animation
                const jitterX = (Math.random() * 80) - 40;
                const jitterY = (Math.random() * 60) - 30;
                const icon = isCrushingBlow ? 'üí•' : isAuto ? 'üó°Ô∏è' : 'üîÆ';
                const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
                updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: enemy.name, target: target.name, value: dmg, message: `${icon} ${enemy.name}'s ${enemy.castAbility || 'attack'} hits ${target.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
                if (target.health <= 0 && !target.isDead) {
                  target.isDead = true;
                  updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: target.name, message: `üíÄ ${target.name} has died!` }] }));
                }
              }
              enemy.isCasting = false;
              enemy.castStartTime = undefined;
              enemy.castTotalTime = undefined;
              enemy.castProgress = 0;
              enemy.castTarget = undefined;
              enemy.gcdRemaining = Math.max(0, enemy.gcdRemaining); // allow immediate recast if GCD already expired
              // GCD was already set when cast started and has been decrementing
              // If cast time > GCD, GCD is already 0 and enemy can recast immediately
              // Don't continue here - fall through to check GCD and potentially start new cast
            } else {
              continue; // Still casting, don't do anything else
            }
          }

          // If on personal GCD, skip
          if (enemy.gcdRemaining > 0) continue;
          
          // Auto-attack for all enemies, staggered and aimed at tank (fallback to any alive)
          enemy.autoAttackTimer = Math.max(0, enemy.autoAttackTimer - TICK_DURATION);
          if (enemy.autoAttackTimer <= 0) {
            const aaTarget = tank && !tank.isDead ? tank : aliveMembers[Math.floor(Math.random() * aliveMembers.length)];
            if (aaTarget) {
              enemy.isCasting = true;
              enemy.castTarget = aaTarget.id;
              enemy.lastCastTarget = aaTarget.id;
              enemy.castAbility = 'Auto Attack';
              enemy.castStartTime = Date.now();
              enemy.castTotalTime = 0.4; // 0.4s swing/shot
              enemy.gcdRemaining = 0.4; // start GCD at cast start
              enemy.autoAttackTimer = 1.8 + Math.random() * 0.4; // next auto staggered
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: enemy.name, target: '', message: `‚öîÔ∏è ${enemy.name} prepares an auto attack...` }] }));
              continue;
            }
          }
          
          if (enemy.behavior === 'melee') {
            // Melee attacks tank if alive, otherwise random target - 1s GCD
            const meleeTarget = tank || aliveMembers[Math.floor(Math.random() * aliveMembers.length)];
            if (meleeTarget) {
              const effectiveArmor = meleeTarget.armor * (1 + (meleeTarget.armorBuff || 0) / 100);
              const painSuppMult = meleeTarget.damageReduction ? (1 - meleeTarget.damageReduction / 100) : 1;
              const rawDamage = enemy.damage * 1.5 * (shieldActive ? 0.5 : 1);
              
              // Check evasion first (PoE: evasion happens before armor)
              const evasionChance = meleeTarget.evasion ? calculateEvasionChance(meleeTarget.evasion, enemy.damage * 100) : 0;
              let dmg = 0;
              let blocked = false;
              
              if (Math.random() < evasionChance) {
                // Attack evaded, no damage
                updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: enemy.name, target: meleeTarget.name, message: `üí® ${meleeTarget.name} evades ${enemy.name}'s attack!` }] }));
              } else {
                // PoE armor formula: Armor / (Armor + 10 * Damage)
                const armorMult = calculateArmorReduction(effectiveArmor, rawDamage);
                let damageAfterArmor = Math.floor(rawDamage * armorMult * painSuppMult);
                // Check for block (physical attacks)
                const blockChance = (meleeTarget.blockChance || 0) + (meleeTarget.blockBuff || 0);
                blocked = rollBlock(blockChance);
                if (blocked) {
                  damageAfterArmor = Math.floor(damageAfterArmor * (1 - BLOCK_DAMAGE_REDUCTION));
                  meleeTarget.lastBlockTime = Date.now();
                }
                
                // Physical damage hits energy shield first, then life (PoE mechanic)
                const damageResult = calculateDamageWithResistances(
                  damageAfterArmor,
                  'physical',
                  {
                    health: meleeTarget.health,
                    maxHealth: meleeTarget.maxHealth,
                    energyShield: meleeTarget.energyShield || 0,
                    maxEnergyShield: meleeTarget.maxEnergyShield || 0,
                    fireResistance: meleeTarget.fireResistance || 0,
                    coldResistance: meleeTarget.coldResistance || 0,
                    lightningResistance: meleeTarget.lightningResistance || 0,
                    chaosResistance: meleeTarget.chaosResistance || 0
                  }
                );
                
                meleeTarget.energyShield = Math.max(0, damageResult.esRemaining);
                meleeTarget.health = Math.max(0, damageResult.lifeRemaining);
                dmg = damageResult.totalDamage;
                meleeTarget.recentDamageTaken = (meleeTarget.recentDamageTaken || 0) + dmg;
                if (dmg > 0) {
                  setTeamFightAnim(prev => prev + 1); // Trigger team hit animation
                  setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 })); // Trigger enemy attack animation
                  const jitterX = (Math.random() * 80) - 40;
                  const jitterY = (Math.random() * 60) - 30;
                  const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
                  updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: enemy.name, target: meleeTarget.name, value: dmg, message: `‚öîÔ∏è ${enemy.name} hits ${meleeTarget.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
                }
                if (meleeTarget.health <= 0 && !meleeTarget.isDead) {
                  meleeTarget.isDead = true;
                  updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: meleeTarget.name, message: `üíÄ ${meleeTarget.name} has died!` }] }));
                }
              }
            }
            enemy.gcdRemaining = 1; // 1 second GCD starts when ability is used

            // Skeleton Warrior special: cleave AOE every 3s, hits all alive players
            if (enemy.enemyId === 'skeleton_warrior') {
              if (enemy.aoeCooldown === undefined) enemy.aoeCooldown = 0;
              enemy.aoeCooldown = Math.max(0, enemy.aoeCooldown - TICK_DURATION);
              if (enemy.aoeCooldown <= 0 && aliveMembers.length > 0) {
                const cleaveDmgBase = enemy.damage * 0.6; // softer than single hit
                const rawCleaveDamage = cleaveDmgBase * (shieldActive ? 0.5 : 1);
                aliveMembers.forEach(member => {
                  const effectiveArmor = member.armor * (1 + (member.armorBuff || 0) / 100);
                  const painSuppMult = member.damageReduction ? (1 - member.damageReduction / 100) : 1;
                  // PoE armor formula
                  const armorMult = calculateArmorReduction(effectiveArmor, rawCleaveDamage);
                  let damageAfterArmor = Math.floor(rawCleaveDamage * armorMult * painSuppMult);
                  const blockChance = (member.blockChance || 0) + (member.blockBuff || 0);
                  const blocked = rollBlock(blockChance);
                  if (blocked) {
                    damageAfterArmor = Math.floor(damageAfterArmor * (1 - BLOCK_DAMAGE_REDUCTION));
                    member.lastBlockTime = Date.now();
                  }
                  
                  // Physical damage hits energy shield first, then life (PoE mechanic)
                  const damageResult = calculateDamageWithResistances(
                    damageAfterArmor,
                    'physical',
                    {
                      health: member.health,
                      maxHealth: member.maxHealth,
                      energyShield: member.energyShield || 0,
                      maxEnergyShield: member.maxEnergyShield || 0,
                      fireResistance: member.fireResistance || 0,
                      coldResistance: member.coldResistance || 0,
                      lightningResistance: member.lightningResistance || 0,
                      chaosResistance: member.chaosResistance || 0
                    }
                  );
                  
                  member.energyShield = Math.max(0, damageResult.esRemaining);
                  member.health = Math.max(0, damageResult.lifeRemaining);
                  const cleave = damageResult.totalDamage;
                  member.recentDamageTaken = (member.recentDamageTaken || 0) + cleave;
                  const jitterX = (Math.random() * 80) - 40;
                  const jitterY = (Math.random() * 60) - 30;
                  const floatNum = createFloatingNumber(cleave, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
                  updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum] }));
                  if (member.health <= 0 && !member.isDead) {
                    member.isDead = true;
                    updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: member.name, message: `üíÄ ${member.name} has died!` }] }));
                  }
                });
                setTeamFightAnim(prev => prev + 1);
                setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 }));
                updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: enemy.name, target: 'ALL', value: 0, message: `‚öîÔ∏è ${enemy.name} cleaves everyone!` }] }));
                enemy.aoeCooldown = 3;
                enemy.gcdRemaining = 3;
              }
            }
          } else if (enemy.behavior === 'tankbuster') {
            // Tankbusters cast Crushing Blow on tank every 3 seconds (uninterruptable)
            if (enemy.crushingBlowCooldown === undefined) enemy.crushingBlowCooldown = 0;
            enemy.crushingBlowCooldown = Math.max(0, enemy.crushingBlowCooldown - TICK_DURATION);
            
            if (enemy.crushingBlowCooldown <= 0 && tank && !tank.isDead) {
              enemy.isCasting = true;
              enemy.castTarget = tank.id;
              enemy.lastCastTarget = tank.id;
              enemy.castAbility = 'Crushing Blow';
              enemy.castStartTime = Date.now();
              enemy.castTotalTime = 2.0; // 2 second cast
              enemy.gcdRemaining = 2.0; // GCD starts when cast begins
              enemy.crushingBlowCooldown = 3.0; // 3 second cooldown
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: enemy.name, target: tank.name, message: `üí• ${enemy.name} begins casting Crushing Blow on ${tank.name}... (UNINTERRUPTABLE!)` }] }));
            } else if (!tank || tank.isDead) {
              // If no tank, just do regular melee attacks
              const meleeTarget = aliveMembers[Math.floor(Math.random() * aliveMembers.length)];
              if (meleeTarget) {
                const effectiveArmor = meleeTarget.armor * (1 + (meleeTarget.armorBuff || 0) / 100);
                const painSuppMult = meleeTarget.damageReduction ? (1 - meleeTarget.damageReduction / 100) : 1;
                const rawDamage = enemy.damage * 1.5 * (shieldActive ? 0.5 : 1);
                
                // Check evasion first
                const evasionChance = meleeTarget.evasion ? calculateEvasionChance(meleeTarget.evasion, enemy.damage * 100) : 0;
                let dmg = 0;
                let blocked = false;
                
                if (Math.random() < evasionChance) {
                  updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: enemy.name, target: meleeTarget.name, message: `üí® ${meleeTarget.name} evades ${enemy.name}'s attack!` }] }));
                } else {
                  const armorMult = calculateArmorReduction(effectiveArmor, rawDamage);
                  let damageAfterArmor = Math.floor(rawDamage * armorMult * painSuppMult);
                  const blockChance = (meleeTarget.blockChance || 0) + (meleeTarget.blockBuff || 0);
                  blocked = rollBlock(blockChance);
                  if (blocked) {
                    damageAfterArmor = Math.floor(damageAfterArmor * (1 - BLOCK_DAMAGE_REDUCTION));
                    meleeTarget.lastBlockTime = Date.now();
                  }
                  
                  // Physical damage hits energy shield first, then life (PoE mechanic)
                  const damageResult = calculateDamageWithResistances(
                    damageAfterArmor,
                    'physical',
                    {
                      health: meleeTarget.health,
                      maxHealth: meleeTarget.maxHealth,
                      energyShield: meleeTarget.energyShield || 0,
                      maxEnergyShield: meleeTarget.maxEnergyShield || 0,
                      fireResistance: meleeTarget.fireResistance || 0,
                      coldResistance: meleeTarget.coldResistance || 0,
                      lightningResistance: meleeTarget.lightningResistance || 0,
                      chaosResistance: meleeTarget.chaosResistance || 0
                    }
                  );
                  
                  meleeTarget.energyShield = Math.max(0, damageResult.esRemaining);
                  meleeTarget.health = Math.max(0, damageResult.lifeRemaining);
                  dmg = damageResult.totalDamage;
                  meleeTarget.recentDamageTaken = (meleeTarget.recentDamageTaken || 0) + dmg;
                  if (dmg > 0) {
                    setTeamFightAnim(prev => prev + 1);
                    setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 }));
                    const jitterX = (Math.random() * 80) - 40;
                    const jitterY = (Math.random() * 60) - 30;
                    const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
                    updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: enemy.name, target: meleeTarget.name, value: dmg, message: `‚öîÔ∏è ${enemy.name} hits ${meleeTarget.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
                  }
                  if (meleeTarget.health <= 0 && !meleeTarget.isDead) {
                    meleeTarget.isDead = true;
                    updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: meleeTarget.name, message: `üíÄ ${meleeTarget.name} has died!` }] }));
                  }
                }
              }
              enemy.gcdRemaining = 1;
            }
          } else if (enemy.behavior === 'caster') {
            // Casters cast spells on random targets - use ability from enemy definition
            const enemyDef = getEnemyById(enemy.enemyId);
            // Get first ability (casters have one spell each)
            const spellAbility = enemyDef?.abilities?.[0];
            const castTime = spellAbility?.castTime || 1.5;
            const abilityName = spellAbility?.name || 'Spell';
            const casterTarget = aliveMembers[Math.floor(Math.random() * aliveMembers.length)];
            if (casterTarget) {
              enemy.isCasting = true;
              enemy.castTarget = casterTarget.id;
              enemy.lastCastTarget = casterTarget.id;
              enemy.castAbility = abilityName;
              enemy.castStartTime = Date.now();
              enemy.castTotalTime = castTime;
              enemy.gcdRemaining = castTime; // GCD starts when cast begins
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: enemy.name, target: casterTarget.name, message: `üîÆ ${enemy.name} begins casting ${abilityName} on ${casterTarget.name}...` }] }));
            }
          } else if (enemy.behavior === 'archer') {
            // Archers shoot at random targets, spreading damage - 0.4s cast, 0.4s GCD
            const targetPool = aliveMembers.filter(m => m.id !== enemy.lastShotTarget || aliveMembers.length === 1);
            if (targetPool.length > 0) {
              const target = targetPool[Math.floor(Math.random() * targetPool.length)];
              enemy.lastShotTarget = target.id; // Track who we're shooting
              const effectiveArmor = target.armor * (1 + (target.armorBuff || 0) / 100);
              const painSuppMult = target.damageReduction ? (1 - target.damageReduction / 100) : 1;
              const rawDamage = enemy.damage * 1.5 * (shieldActive ? 0.5 : 1) * 0.7;
              
              // Check evasion first
              const evasionChance = target.evasion ? calculateEvasionChance(target.evasion, enemy.damage * 100) : 0;
              let dmg = 0;
              let blocked = false;
              
              if (Math.random() < evasionChance) {
                updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: enemy.name, target: target.name, message: `üí® ${target.name} evades ${enemy.name}'s shot!` }] }));
              } else {
                // PoE armor formula
                const armorMult = calculateArmorReduction(effectiveArmor, rawDamage);
                let damageAfterArmor = Math.floor(rawDamage * armorMult * painSuppMult);
                // Check for block (physical attacks)
                const blockChance = (target.blockChance || 0) + (target.blockBuff || 0);
                blocked = rollBlock(blockChance);
                if (blocked) {
                  damageAfterArmor = Math.floor(damageAfterArmor * (1 - BLOCK_DAMAGE_REDUCTION));
                  target.lastBlockTime = Date.now();
                }
                
                // Physical damage hits energy shield first, then life (PoE mechanic)
                const damageResult = calculateDamageWithResistances(
                  damageAfterArmor,
                  'physical',
                  {
                    health: target.health,
                    maxHealth: target.maxHealth,
                    energyShield: target.energyShield || 0,
                    maxEnergyShield: target.maxEnergyShield || 0,
                    fireResistance: target.fireResistance || 0,
                    coldResistance: target.coldResistance || 0,
                    lightningResistance: target.lightningResistance || 0,
                    chaosResistance: target.chaosResistance || 0
                  }
                );
                
                target.energyShield = Math.max(0, damageResult.esRemaining);
                target.health = Math.max(0, damageResult.lifeRemaining);
                dmg = damageResult.totalDamage;
                target.recentDamageTaken = (target.recentDamageTaken || 0) + dmg;
                if (dmg > 0) {
                  setTeamFightAnim(prev => prev + 1); // Trigger team hit animation
                  setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 })); // Trigger enemy attack animation
                  const jitterX = (Math.random() * 80) - 40;
                  const jitterY = (Math.random() * 60) - 30;
                  const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
                  updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: enemy.name, target: target.name, value: dmg, message: `üèπ ${enemy.name} shoots ${target.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
                }
                if (target.health <= 0 && !target.isDead) {
                  target.isDead = true;
                  updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: target.name, message: `üíÄ ${target.name} has died!` }] }));
                }
              }
              enemy.gcdRemaining = 0.4; // 0.4 second GCD for archers
            } else if (enemy.behavior === 'aoe') {
              // AOE damage - hits ALL party members (unkickable!) 
              // AOE enemies pulse damage on a consistent timer
              const isGateBoss = enemy.type === 'miniboss' || enemy.type === 'boss';
              const aoeCooldownTime = isGateBoss ? 5 : 3;
              
              // Check if ready to pulse (aoeCooldown tracks time until next pulse)
              if ((enemy.aoeCooldown || 0) <= 0) {
                const aoeDmgMultiplier = isGateBoss ? 0.25 : 0.35;
                const abilityName = isGateBoss ? 'üí• Devastating Slam' : 'üåÄ Dark Pulse';
                
                // Get fresh list of alive members for this attack
                const currentAliveMembers = teamStates.filter(m => !m.isDead);
                if (currentAliveMembers.length > 0) {
                  let totalAoeDamage = 0;
                  const newFloats: FloatingNumber[] = [];
                  currentAliveMembers.forEach(member => {
                    const effectiveArmor = member.armor * (1 + (member.armorBuff || 0) / 100);
                    const painSuppMult = member.damageReduction ? (1 - member.damageReduction / 100) : 1;
                    const rawAoeDamage = enemy.damage * 1.5 * (shieldActive ? 0.5 : 1) * aoeDmgMultiplier;
                    
                    // PoE armor formula
                    const armorMult = calculateArmorReduction(effectiveArmor, rawAoeDamage);
                    let dmg = Math.floor(rawAoeDamage * armorMult * painSuppMult);
                    // Check for block (physical AOE)
                    const blockChance = (member.blockChance || 0) + (member.blockBuff || 0);
                    const blocked = rollBlock(blockChance);
                    if (blocked) {
                      dmg = Math.floor(dmg * (1 - BLOCK_DAMAGE_REDUCTION));
                      member.lastBlockTime = Date.now();
                    }
                    member.health = Math.max(0, member.health - dmg);
                    member.recentDamageTaken = (member.recentDamageTaken || 0) + dmg;
                    setTeamFightAnim(prev => prev + 1); // Trigger team hit animation
                    totalAoeDamage += dmg;
                    const jitterX = (Math.random() * 80) - 40;
                    const jitterY = (Math.random() * 60) - 30;
                    newFloats.push(createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY));
                    
                    if (member.health <= 0 && !member.isDead) {
                      member.isDead = true;
                      updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: member.name, message: `üíÄ ${member.name} has died!` }] }));
                    }
                  });
                  
                  setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 })); // Trigger enemy attack animation
                  
                  updateCombatState(prev => ({ 
                    ...prev, 
                    floatingNumbers: [...prev.floatingNumbers.slice(-20), ...newFloats].slice(-20),
                    combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: enemy.name, target: 'ALL', value: totalAoeDamage, message: `${abilityName} from ${enemy.name} hits EVERYONE for ${Math.floor(totalAoeDamage / currentAliveMembers.length)} each!` }] 
                  }));
                }
                
                // Set cooldown and GCD - use aoeCooldown as the primary timer
                enemy.aoeCooldown = aoeCooldownTime;
                enemy.gcdRemaining = aoeCooldownTime; // Sync GCD with AOE cooldown
              } else {
                // AOE enemy is waiting for cooldown, set GCD to remaining cooldown
                enemy.gcdRemaining = enemy.aoeCooldown;
              }
            }
          }
        }
      }

      // Healer healing with cast times - find healer fresh from teamStates
      const currentHealer = teamStates.find(m => m.role === 'healer' && !m.isDead);
      if (currentHealer) {
        const healerChar = team.find(c => c.id === currentHealer.id);
        // PoE: Spell power scales with intelligence (simplified: use intelligence as base)
        const spellPower = (healerChar?.baseStats?.intelligence || 20) * 5; // Scale intelligence to spell power
        
        // If healer is currently casting - use real elapsed time
        if (currentHealer.isCasting && currentHealer.castStartTime && currentHealer.castTotalTime) {
          const castTarget = teamStates.find(m => m.id === currentHealer.castTargetId);
          const elapsedMs = Date.now() - currentHealer.castStartTime;
          const castComplete = elapsedMs >= (currentHealer.castTotalTime * 1000);
          
          if (!castTarget || castTarget.isDead) {
            currentHealer.isCasting = false;
            currentHealer.castProgress = 0;
            currentHealer.castTargetId = undefined;
            updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: currentHealer.name, target: '', message: `‚ùå ${currentHealer.name}'s heal was cancelled - target died!` }] }));
            // Fall through to start new cast
          } else if (castComplete) {
            const abilityName = currentHealer.castAbility || 'Healing Wave';
            
            // Get the actual skill data
            const skillId = getSkillIdFromAbilityName(abilityName);
            const skill = skillId ? getSkillGemById(skillId) : undefined;
            
            if (!skill || !skill.baseHealing) {
              currentHealer.isCasting = false;
              currentHealer.castTargetId = undefined;
              return;
            }
            
            // Check mana cost
            if (currentHealer.mana < skill.manaCost) {
              currentHealer.isCasting = false;
              currentHealer.castTargetId = undefined;
              return;
            }
            
            // Use actual skill healing and scaling
            const spellPowerMultiplier = skill.spellPowerScaling || 1.0;
            const baseHeal = skill.baseHealing || 100;
            const healAmount = Math.floor(baseHeal * (1 + (spellPower * spellPowerMultiplier) / 100));
            
            // Check for critical heal
            // PoE-style crit: base crit chance * (1 + increased crit chance / 100)
            const baseCritChance = skill.baseCriticalStrikeChance || 8;
            const increasedCritChance = healerChar?.baseStats?.criticalStrikeChance || 0;
            const finalCritChance = calculateCriticalStrikeChance(baseCritChance, increasedCritChance);
            const isCritHeal = Math.random() < (finalCritChance / 100);
            const critMultiplier = (healerChar?.baseStats?.criticalStrikeMultiplier || 150) / 100;
            const finalHealAmount = isCritHeal ? Math.floor(healAmount * critMultiplier) : healAmount;
              const actualHeal = Math.min(castTarget.maxHealth - castTarget.health, finalHealAmount);
              castTarget.health = Math.min(castTarget.maxHealth, castTarget.health + finalHealAmount);
              const healTimestamp = Date.now();
              castTarget.lastHealTime = healTimestamp;
              castTarget.lastHealAmount = actualHeal;
              castTarget.lastHealCrit = isCritHeal;
              if (isCritHeal) setScreenShake(prev => prev + 1);
              currentHealer.mana -= skill.manaCost;
              currentHealer.totalHealing = (currentHealer.totalHealing || 0) + actualHeal;
              currentHealer.healingBySpell = currentHealer.healingBySpell || {};
              currentHealer.healingBySpell[abilityName] = (currentHealer.healingBySpell[abilityName] || 0) + actualHeal;
              
              const jitterX = (Math.random() * 80) - 40;
              const jitterY = (Math.random() * 60) - 30;
              const floatNum = createFloatingNumber(healAmount, 'heal', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 50 + jitterY);
              updateCombatState(prev => ({ 
                ...prev, 
                teamStates: prev.teamStates.map(m => 
                  m.id === castTarget.id 
                    ? { ...m, lastHealTime: healTimestamp, lastHealAmount: actualHeal, lastHealCrit: isCritHeal, health: castTarget.health }
                    : m.id === currentHealer.id
                    ? { ...m, mana: currentHealer.mana, totalHealing: currentHealer.totalHealing, healingBySpell: currentHealer.healingBySpell }
                    : m
                ),
                floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum],
                combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'heal', source: currentHealer.name, target: castTarget.name, value: healAmount, message: `${skill.icon} ${currentHealer.name} casts ${abilityName} on ${castTarget.name} for ${healAmount}${isCritHeal ? ' CRIT!' : ''}!` }] 
              }));
            }
            
            currentHealer.isCasting = false;
            currentHealer.castTargetId = undefined;
            // Fall through to immediately start next cast
          }
        }
        
        // Not casting (or just finished) - decide what to cast if GCD is done
        const healerGcdReady = !currentHealer.gcdEndTime || Date.now() >= currentHealer.gcdEndTime;
        if (!currentHealer.isCasting && healerGcdReady) {
          // Not casting and off GCD - decide what to cast
          const aliveTeam = teamStates.filter(m => !m.isDead);
          const healerChar = team.find(c => c.id === currentHealer.id);
          
          // Priority 1: Pain Suppression on someone taking heavy damage recently (if off CD)
          const equippedSkillIds = healerChar?.skillGems?.map((sg: any) => sg.skillGemId) || [];
          const hasPainSuppression = equippedSkillIds.includes('pain_suppression');
          const painSuppSkill = hasPainSuppression ? getSkillGemById('pain_suppression') : undefined;
          const painSuppCD = healerCooldowns.painSuppression || 0;
          const heavyDamageTarget = aliveTeam.find(m => 
            (m.recentDamageTaken || 0) > m.maxHealth * 0.15 && 
            !m.damageReduction
          );
          
          if (hasPainSuppression && painSuppSkill && painSuppCD <= 0 && heavyDamageTarget && currentHealer.mana >= painSuppSkill.manaCost) {
            // Instant cast Pain Suppression - use skill's effect value
            const damageReductionValue = painSuppSkill.effects.find(e => e.type === 'damageReduction')?.value || 40;
            const duration = painSuppSkill.effects.find(e => e.type === 'damageReduction')?.duration || 6;
            heavyDamageTarget.damageReduction = damageReductionValue;
            heavyDamageTarget.damageReductionDuration = duration;
            heavyDamageTarget.lastExternalTime = Date.now();
            heavyDamageTarget.lastExternalName = 'Pain Supp';
            currentHealer.mana -= painSuppSkill.manaCost;
            healerCooldowns.painSuppression = painSuppSkill.cooldown || 30;
            currentHealer.gcdEndTime = Date.now() + 1500; // 1.5s GCD
            updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'buff', source: currentHealer.name, target: heavyDamageTarget.name, message: `${painSuppSkill.icon} ${currentHealer.name} casts Pain Suppression on ${heavyDamageTarget.name}! (-${damageReductionValue}% damage for ${duration}s)` }] }));
          }
          // Priority 2: Massive Heal on critically injured (‚â§50% health)
          else {
            const hasMassiveHeal = equippedSkillIds.includes('massive_heal');
            const massiveHealSkill = hasMassiveHeal ? getSkillGemById('massive_heal') : undefined;
            const criticalTarget = aliveTeam.find(m => m.health <= m.maxHealth * 0.5);
            
            if (hasMassiveHeal && massiveHealSkill && criticalTarget && currentHealer.mana >= massiveHealSkill.manaCost) {
              currentHealer.isCasting = true;
              currentHealer.castProgress = Math.ceil(massiveHealSkill.castTime);
              currentHealer.castTotalTime = massiveHealSkill.castTime;
              currentHealer.castStartTime = Date.now();
              currentHealer.gcdEndTime = Date.now() + 1500; // 1.5s GCD starts when cast begins
              currentHealer.castTargetId = criticalTarget.id;
              currentHealer.castAbility = massiveHealSkill.name;
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: currentHealer.name, target: criticalTarget.name, message: `${massiveHealSkill.icon} ${currentHealer.name} begins casting ${massiveHealSkill.name} on ${criticalTarget.name}...` }] }));
            }
            // Priority 3: Rejuvenation on damaged targets above 50% without HoT
            else {
              const hasRejuvenation = equippedSkillIds.includes('rejuvenation');
              const rejuvSkill = hasRejuvenation ? getSkillGemById('rejuvenation') : undefined;
              const rejuvTarget = aliveTeam.find(m => 
                m.health < m.maxHealth * 0.85 && 
                m.health > m.maxHealth * 0.5 && 
                !m.hasRejuv
              );
              
              if (hasRejuvenation && rejuvSkill && rejuvTarget && currentHealer.mana >= rejuvSkill.manaCost) {
                // Instant cast Rejuvenation - use skill's actual healing and scaling
                const spellPower = (healerChar?.baseStats?.intelligence || 20) * 5;
                const spellPowerMultiplier = rejuvSkill.spellPowerScaling || 0.3;
                const baseHeal = rejuvSkill.baseHealing || 40;
                const hotHealPerTick = Math.floor(baseHeal * (1 + (spellPower * spellPowerMultiplier) / 100));
                const duration = rejuvSkill.effects.find(e => e.type === 'hot')?.duration || 12;
                const tickInterval = 2; // HoT ticks every 2 seconds
                
                rejuvTarget.hotEffects = rejuvTarget.hotEffects || [];
                rejuvTarget.hotEffects.push({
                  name: rejuvSkill.name,
                  icon: rejuvSkill.icon,
                  healPerTick: hotHealPerTick,
                  remainingDuration: duration,
                  tickInterval: tickInterval,
                  nextTickIn: tickInterval,
                  sourceId: currentHealer.id
                });
                rejuvTarget.hasRejuv = true;
                currentHealer.mana -= rejuvSkill.manaCost;
                currentHealer.gcdEndTime = Date.now() + 1500; // 1.5s GCD
                updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'heal', source: currentHealer.name, target: rejuvTarget.name, message: `${rejuvSkill.icon} ${currentHealer.name} casts ${rejuvSkill.name} on ${rejuvTarget.name}!` }] }));
              }
              // Priority 4: Healing Wave on anyone hurt
              else {
                const hasHealingWave = equippedSkillIds.includes('healing_wave');
                const healingWaveSkill = hasHealingWave ? getSkillGemById('healing_wave') : undefined;
                const hurtMembers = aliveTeam.filter(m => m.health < m.maxHealth * 0.95);
                
                if (hasHealingWave && healingWaveSkill && hurtMembers.length > 0 && currentHealer.mana >= healingWaveSkill.manaCost) {
                  const tankMember = hurtMembers.find(m => m.role === 'tank');
                  const healTarget = tankMember || hurtMembers.reduce((lowest, m) => 
                    (!lowest || m.health / m.maxHealth < lowest.health / lowest.maxHealth) ? m : lowest, 
                    hurtMembers[0]
                  );
                  
                  currentHealer.isCasting = true;
                  currentHealer.castProgress = Math.ceil(healingWaveSkill.castTime);
                  currentHealer.castTotalTime = healingWaveSkill.castTime;
                  currentHealer.castStartTime = Date.now();
                  currentHealer.gcdEndTime = Date.now() + 1500; // 1.5s GCD starts when cast begins
                  currentHealer.castTargetId = healTarget.id;
                  currentHealer.castAbility = healingWaveSkill.name;
                  updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: currentHealer.name, target: healTarget.name, message: `${healingWaveSkill.icon} ${currentHealer.name} begins casting ${healingWaveSkill.name} on ${healTarget.name}...` }] }));
                }
              }
            }
          }
        }
        
        // Tick Pain Suppression cooldown - use TICK_DURATION
        if (healerCooldowns.painSuppression > 0) {
          healerCooldowns.painSuppression -= TICK_DURATION;
        }

        // Tick Tank cooldowns - use TICK_DURATION
        if (tankCooldowns.shieldSlam > 0) tankCooldowns.shieldSlam -= TICK_DURATION;
        if (tankCooldowns.defensiveStance > 0) tankCooldowns.defensiveStance -= TICK_DURATION;
        if (tankCooldowns.shieldBlock > 0) tankCooldowns.shieldBlock -= TICK_DURATION;
      }

      // Collect DPS spell casts and damage to batch update
      const dpsFloatNumbers: FloatingNumber[] = [];
      const dpsLogEntries: CombatLogEntry[] = [];
      
      // Capture alive enemies ONCE at start of tick - all DPS hit the same targets simultaneously
      const tickAliveEnemies = currentEnemies.filter(e => e.health > 0);

      // Team DPS - all on 1s GCD, everyone attacks each tick
      team.forEach((char) => {
        const member = teamStates.find(m => m.id === char.id);
        if (!member || member.isDead) return;
        
        // Healer should NOT attack if they are casting OR if someone needs healing
        if (char.role === 'healer') {
          if (member.isCasting) return; // Currently casting a heal
          const hurtMembers = teamStates.filter(m => !m.isDead && m.health < m.maxHealth * 0.95);
          if (hurtMembers.length > 0) return; // Someone needs healing, don't attack
        }
        
        // DPS spell casting logic
        if (char.role === 'dps') {
          // If DPS is currently casting a spell - use real elapsed time
          // Cast progress is tracked via real-time (castStartTime + castTotalTime)
          if (member.isCasting && member.castStartTime && member.castTotalTime) {
            const elapsedMs = Date.now() - member.castStartTime;
            const castComplete = elapsedMs >= (member.castTotalTime * 1000);
            
            // Cast complete!
            if (castComplete) {
              // Get the actual skill data from equipped skills
              const abilityName = member.castAbility || 'Fireball';
              const skillId = getSkillIdFromAbilityName(abilityName);
              const skill = skillId ? getSkillGemById(skillId) : undefined;
              
              if (!skill || !skill.baseDamage) {
                // Fallback if skill not found
                member.isCasting = false;
                member.castAbility = undefined;
                member.castTargetId = undefined;
                return;
              }
              
              // PoE: Spell power scales with intelligence
              const spellPower = (char.baseStats?.intelligence || 20) * 5;
              // PoE-style crit: base crit chance * (1 + increased crit chance / 100)
              const baseCritChance = skill.baseCriticalStrikeChance || 8;
              const increasedCritChance = char.baseStats?.criticalStrikeChance || 0;
              const finalCritChance = calculateCriticalStrikeChance(baseCritChance, increasedCritChance);
              const isCrit = Math.random() < (finalCritChance / 100);
              
              // Use actual skill damage and scaling
              const spellPowerMultiplier = skill.spellPowerScaling || 1.0;
              const baseDmg = skill.baseDamage || 150;
              const damage = Math.floor(baseDmg * (1 + (spellPower * spellPowerMultiplier) / 100) * (bloodlustActive ? 1.3 : 1));
              const critMultiplier = (char.baseStats?.criticalStrikeMultiplier || 150) / 100;
              const finalDamage = isCrit ? Math.floor(damage * critMultiplier) : damage;
              
              // Use the tick's snapshot of alive enemies so all DPS hit same targets
              const currentAlive = tickAliveEnemies;
              const dpsIndex = team.filter(c => c.role === 'dps').findIndex(c => c.id === char.id);
              const jitterX = (Math.random() * 100) - 50 + (dpsIndex * 40);
              const jitterY = (Math.random() * 70) - 35 - (dpsIndex * 15);
              
              // Check mana cost
              if (member.mana < skill.manaCost) {
                member.isCasting = false;
                member.castAbility = undefined;
                member.castTargetId = undefined;
                return;
              }
              
              member.mana -= skill.manaCost;
              
              // Handle damage conversion (PoE style - e.g., Blow Up converts 100% physical to fire)
              let actualDamageType: 'physical' | 'fire' | 'cold' | 'lightning' | 'chaos' | 'shadow' | 'holy' | 'magic' = skill.damageType || 'fire';
              if (skill.physicalToFireConversion && skill.physicalToFireConversion > 0) {
                // Convert physical damage to fire (e.g., Blow Up)
                actualDamageType = 'fire';
              }
              
              // Handle different target types based on skill definition
              if (skill.targetType === 'allEnemies') {
                // AOE damage to ALL enemies (Blow Up)
                let totalDamage = 0;
                currentAlive.forEach(enemy => {
                  enemy.health = Math.max(0, enemy.health - finalDamage);
                  totalDamage += finalDamage;
                  setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 }));
                });
                member.totalDamage = (member.totalDamage || 0) + totalDamage;
                member.damageBySpell = member.damageBySpell || {};
                member.damageBySpell[abilityName] = (member.damageBySpell[abilityName] || 0) + totalDamage;
                if (isCrit) setScreenShake(prev => prev + 1);
                setTeamFightAnim(prev => prev + 1);
                dpsFloatNumbers.push(createFloatingNumber(totalDamage, isCrit ? 'crit' : 'player', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY));
                dpsLogEntries.push({ timestamp: totalTime, type: 'damage', source: char.name, target: `${currentAlive.length} enemies`, value: totalDamage, message: `${skill.icon} ${char.name} casts ${abilityName} hitting ${currentAlive.length} enemies for ${finalDamage} each${isCrit ? ' CRIT!' : ''}!` });
              } else if (skill.targetType === 'enemy' && skill.name === 'Shadow Bolt') {
                // Shadow Bolt - special case: hits up to 3 targets (multi-target)
                const targets = [...currentAlive].sort((a, b) => a.health - b.health).slice(0, 3);
                let totalDamage = 0;
                targets.forEach(enemy => {
                  enemy.health = Math.max(0, enemy.health - finalDamage);
                  totalDamage += finalDamage;
                  setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 }));
                });
                member.totalDamage = (member.totalDamage || 0) + totalDamage;
                member.damageBySpell = member.damageBySpell || {};
                member.damageBySpell[abilityName] = (member.damageBySpell[abilityName] || 0) + totalDamage;
                if (isCrit) setScreenShake(prev => prev + 1);
                setTeamFightAnim(prev => prev + 1);
                dpsFloatNumbers.push(createFloatingNumber(totalDamage, isCrit ? 'crit' : 'player', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY));
                const targetNames = targets.length === 1 ? targets[0].name : `${targets.length} enemies`;
                dpsLogEntries.push({ timestamp: totalTime, type: 'damage', source: char.name, target: targetNames, value: totalDamage, message: `${skill.icon} ${char.name} casts ${abilityName} hitting ${targetNames} for ${finalDamage} each${isCrit ? ' CRIT!' : ''}!` });
              } else {
                // Single target (Fireball or other single-target)
                if (currentAlive.length > 0) {
                  let target = member.castTargetId ? currentAlive.find(e => e.id === member.castTargetId) : null;
                  if (!target) {
                    target = currentAlive.reduce((lowest, e) => e.health < lowest.health ? e : lowest, currentAlive[0]);
                  }
                  target.health = Math.max(0, target.health - finalDamage);
                  member.totalDamage = (member.totalDamage || 0) + finalDamage;
                  member.damageBySpell = member.damageBySpell || {};
                  member.damageBySpell[abilityName] = (member.damageBySpell[abilityName] || 0) + finalDamage;
                  if (isCrit) setScreenShake(prev => prev + 1);
                  setTeamFightAnim(prev => prev + 1);
                  setEnemyFightAnims(prev => ({ ...prev, [target.id]: (prev[target.id] || 0) + 1 }));
                  dpsFloatNumbers.push(createFloatingNumber(finalDamage, isCrit ? 'crit' : 'player', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY));
                  dpsLogEntries.push({ timestamp: totalTime, type: 'damage', source: char.name, target: target.name, value: finalDamage, message: `${skill.icon} ${char.name} casts ${abilityName} on ${target.name} for ${finalDamage}${isCrit ? ' CRIT!' : ''}!` });
                }
              }
              
              member.isCasting = false;
              member.castAbility = undefined;
              member.castTargetId = undefined;
              // Fall through to immediately start next cast (no return here!)
            } else {
              return; // Still casting, don't do anything else
            }
          }
          
          // Not casting (or just finished) - start a new cast if GCD is done
          const currentAlive = tickAliveEnemies;
          const gcdReady = !member.gcdEndTime || Date.now() >= member.gcdEndTime;
          if (gcdReady && currentAlive.length > 0) {
            // Check what spells this character has equipped
            const equippedSkillIds = char.skillGems?.map(sg => sg.skillGemId) || [];
            const hasBlowUp = equippedSkillIds.includes('blow_up');
            const hasShadowBolt = equippedSkillIds.includes('shadow_bolt');
            const hasFireball = equippedSkillIds.includes('fireball');
            
            // Get equipped skills as SkillGem objects
            const equippedSkills = equippedSkillIds
              .map(id => getSkillGemById(id))
              .filter((skill): skill is NonNullable<typeof skill> => skill !== undefined && skill.baseDamage !== undefined);
            
            if (equippedSkills.length === 0) {
              return; // No damage skills equipped
            }
            
            // Choose best available spell based on enemy count and skill target types
            let selectedSkill: typeof equippedSkills[0] | null = null;
            
            if (currentAlive.length >= 3) {
              // Prefer AOE skills for 3+ enemies
              selectedSkill = equippedSkills.find(s => s.targetType === 'allEnemies') 
                || equippedSkills.find(s => s.id === 'shadow_bolt') // Shadow Bolt is multi-target
                || equippedSkills.find(s => s.targetType === 'enemy')
                || equippedSkills[0];
            } else if (currentAlive.length === 2) {
              // Prefer multi-target for 2 enemies
              selectedSkill = equippedSkills.find(s => s.id === 'shadow_bolt') // Shadow Bolt is multi-target
                || equippedSkills.find(s => s.targetType === 'allEnemies')
                || equippedSkills.find(s => s.targetType === 'enemy')
                || equippedSkills[0];
            } else {
              // Prefer single-target for 1 enemy
              selectedSkill = equippedSkills.find(s => s.targetType === 'enemy')
                || equippedSkills.find(s => s.id === 'shadow_bolt')
                || equippedSkills.find(s => s.targetType === 'allEnemies')
                || equippedSkills[0];
            }
            
            if (!selectedSkill || member.mana < selectedSkill.manaCost) {
              return; // Can't cast
            }
            
            const spellChoice = selectedSkill.name;
            const castTimeSeconds = selectedSkill.castTime || 0;
            
            // For single-target spells, pick target now and avoid targets already being cast on
            let targetId: string | undefined = undefined;
            if (selectedSkill && selectedSkill.targetType === 'enemy' && selectedSkill.id !== 'shadow_bolt') {
              // Get IDs of enemies already being targeted by other casters
              const alreadyTargeted = new Set(
                teamStates
                  .filter(m => m.isCasting && m.castTargetId && m.id !== member.id)
                  .map(m => m.castTargetId)
              );
              
              // Find lowest health enemy not already being targeted
              const availableTargets = currentAlive.filter(e => !alreadyTargeted.has(e.id));
              const targetPool = availableTargets.length > 0 ? availableTargets : currentAlive; // Fall back to all if all targeted
              const target = targetPool.reduce((lowest, e) => e.health < lowest.health ? e : lowest, targetPool[0]);
              targetId = target.id;
            }
            
            member.isCasting = true;
            member.castProgress = Math.ceil(castTimeSeconds); // Ticks needed (for game logic)
            member.castTotalTime = castTimeSeconds; // Actual cast time for smooth animation
            member.castStartTime = Date.now();
            member.gcdEndTime = Date.now() + 1500; // 1.5s GCD starts NOW when cast begins
            member.castAbility = spellChoice;
            member.castTargetId = targetId; // Store target for single-target spells
            
            const targetName = targetId ? currentAlive.find(e => e.id === targetId)?.name : '';
            dpsLogEntries.push({ timestamp: totalTime, type: 'ability', source: char.name, target: targetName || '', message: `üîÆ ${char.name} begins casting ${spellChoice}${targetName ? ` on ${targetName}` : ''}...` });
          }
          return;
        }
        
        // Tank-specific ability logic
        if (char.role === 'tank') {
          const tankGcdReady = !member.gcdEndTime || Date.now() >= member.gcdEndTime;
          if (!tankGcdReady) return;
        
          // PoE: Damage scales with strength, crit chance is separate stat
          const strength = char.baseStats?.strength || 20;
          // PoE-style crit: base crit chance * (1 + increased crit chance / 100)
          const skillId = 'shield_slam'; // Tank uses Shield Slam
          const skill = getSkillGemById(skillId);
          const baseCritChance = skill?.baseCriticalStrikeChance || 5;
          const increasedCritChance = char.baseStats?.criticalStrikeChance || 0;
          const finalCritChance = calculateCriticalStrikeChance(baseCritChance, increasedCritChance);
          const isCrit = Math.random() < (finalCritChance / 100);
          
          // Check equipped skills
          const equippedSkillIds = char.skillGems?.map(sg => sg.skillGemId) || [];
          const hasShieldSlam = equippedSkillIds.includes('shield_slam');
          const hasDefensiveStance = equippedSkillIds.includes('defensive_stance');
          const hasShieldBlock = equippedSkillIds.includes('shield_block');
          
          // Get alive enemies for this tick
          const aliveEnemies = tickAliveEnemies;
          
          // Priority 1: Shield Block when taking damage and no block buff active
          if (hasShieldBlock && tankCooldowns.shieldBlock <= 0 && !member.blockBuff) {
            const shieldBlockSkill = getSkillGemById('shield_block');
            if (shieldBlockSkill && (member.recentDamageTaken || 0) > member.maxHealth * 0.03 && member.mana >= shieldBlockSkill.manaCost) {
              const blockValue = shieldBlockSkill.effects.find((e: any) => e.type === 'buffStat')?.value || 30;
              const duration = shieldBlockSkill.effects.find((e: any) => e.type === 'buffStat')?.duration || 6;
              member.blockBuff = blockValue; // +30% block and spell block chance
              member.blockBuffDuration = duration;
              member.mana -= shieldBlockSkill.manaCost;
              tankCooldowns.shieldBlock = shieldBlockSkill.cooldown || 12;
              member.gcdEndTime = Date.now() + 1500; // 1.5s GCD
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'buff', source: char.name, target: char.name, message: `${shieldBlockSkill.icon} ${char.name} raises Shield Block! (+${blockValue}% block for ${duration}s)` }] }));
              return;
            }
          }
          
          // Priority 2: Defensive Stance if taking damage and no armor buff active
          if (hasDefensiveStance && tankCooldowns.defensiveStance <= 0 && !member.armorBuff) {
            const defensiveStanceSkill = getSkillGemById('defensive_stance');
            if (defensiveStanceSkill && (member.recentDamageTaken || 0) > member.maxHealth * 0.05 && member.mana >= defensiveStanceSkill.manaCost) {
              const armorValue = defensiveStanceSkill.effects.find((e: any) => e.type === 'buffStat')?.value || 50;
              const duration = defensiveStanceSkill.effects.find((e: any) => e.type === 'buffStat')?.duration || 15;
              member.armorBuff = armorValue; // 50% armor increase
              member.armorBuffDuration = duration;
              member.mana -= defensiveStanceSkill.manaCost;
              tankCooldowns.defensiveStance = defensiveStanceSkill.cooldown || 30;
              member.gcdEndTime = Date.now() + 1500; // 1.5s GCD
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'buff', source: char.name, target: char.name, message: `${defensiveStanceSkill.icon} ${char.name} enters Defensive Stance! (+${armorValue}% armor for ${duration}s)` }] }));
              return;
            }
          }
          
          if (aliveEnemies.length > 0) {
            // Priority 3: Shield Slam for single-target damage (off cooldown)
            if (hasShieldSlam && tankCooldowns.shieldSlam <= 0) {
              const shieldSlamSkill = getSkillGemById('shield_slam');
              if (shieldSlamSkill && member.mana >= shieldSlamSkill.manaCost) {
                const target = aliveEnemies.reduce((lowest: any, e: any) => e.health < lowest.health ? e : lowest, aliveEnemies[0]);
                
                // Use actual skill damage and scaling
                const attackPowerMultiplier = shieldSlamSkill.attackPowerScaling || 1.0;
                const baseDmg = shieldSlamSkill.baseDamage || 75;
                // PoE: Strength scales melee damage (+0.2% per strength)
                const strengthBonus = 1 + (strength * 0.002);
                const shieldSlamDmg = Math.floor(baseDmg * attackPowerMultiplier * strengthBonus * (bloodlustActive ? 1.3 : 1));
                const critMultiplier = (char.baseStats?.criticalStrikeMultiplier || 150) / 100;
                const finalDamage = isCrit ? Math.floor(shieldSlamDmg * critMultiplier) : shieldSlamDmg;
                
                target.health = Math.max(0, target.health - finalDamage);
                member.totalDamage = (member.totalDamage || 0) + finalDamage;
                member.damageBySpell = member.damageBySpell || {};
                member.damageBySpell['Shield Slam'] = (member.damageBySpell['Shield Slam'] || 0) + finalDamage;
                member.mana -= shieldSlamSkill.manaCost;
                tankCooldowns.shieldSlam = shieldSlamSkill.cooldown || 6;
                member.gcdEndTime = Date.now() + 1500; // 1.5s GCD
                
                const jitterX = (Math.random() * 80) - 40;
                const jitterY = (Math.random() * 60) - 30;
                if (isCrit) setScreenShake(prev => prev + 1);
                setTeamFightAnim(prev => prev + 1);
                setEnemyFightAnims(prev => ({ ...prev, [target.id]: (prev[target.id] || 0) + 1 }));
                const floatNum = createFloatingNumber(finalDamage, isCrit ? 'crit' : 'player', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
                updateCombatState(prev => ({ 
                  ...prev, 
                  floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum],
                  combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: char.name, target: target.name, value: finalDamage, message: `${shieldSlamSkill.icon} ${char.name} Shield Slams ${target.name} for ${finalDamage}${isCrit ? ' CRIT!' : ''}!` }] 
                }));
                return;
              }
            }
            
            // Fallback: Thunder Clap AOE
            const thunderClapDmg = Math.floor(50 * (1 + strength / 150) * (bloodlustActive ? 1.3 : 1));
            const finalDamage = isCrit ? Math.floor(thunderClapDmg * 1.5) : thunderClapDmg;
            let totalDamageDealt = 0;
            
            aliveEnemies.forEach(enemy => {
              enemy.health = Math.max(0, enemy.health - finalDamage);
              totalDamageDealt += finalDamage;
              setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 })); // Trigger enemy hit animation
            });
            member.totalDamage = (member.totalDamage || 0) + totalDamageDealt;
            member.damageBySpell = member.damageBySpell || {};
            member.damageBySpell['Thunder Clap'] = (member.damageBySpell['Thunder Clap'] || 0) + totalDamageDealt;
            
            const jitterX = (Math.random() * 80) - 40;
            const jitterY = (Math.random() * 60) - 30;
            if (isCrit) setScreenShake(prev => prev + 1);
            setTeamFightAnim(prev => prev + 1); // Trigger team fighting animation
            const floatNum = createFloatingNumber(totalDamageDealt, isCrit ? 'crit' : 'player', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
            updateCombatState(prev => ({ 
              ...prev, 
              floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum],
              combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: char.name, target: aliveEnemies.length > 1 ? `${aliveEnemies.length} enemies` : aliveEnemies[0].name, value: totalDamageDealt, message: `‚ö° ${char.name} Thunder Claps ${aliveEnemies.length > 1 ? aliveEnemies.length + ' enemies' : aliveEnemies[0].name} for ${finalDamage}${isCrit ? ' CRIT!' : ''} each!` }] 
            }));
          }
          member.gcdEndTime = Date.now() + 1500; // 1.5s GCD
          return;
        }
        
        // Healer auto-attack logic
        const autoGcdReady = !member.gcdEndTime || Date.now() >= member.gcdEndTime;
        if (!autoGcdReady) return;
        
        // PoE: Damage scales with strength, crit chance is separate stat
        const strength = char.baseStats?.strength || 20;
        // PoE-style crit: base crit chance * (1 + increased crit chance / 100)
        // Auto-attacks use 5% base crit chance
        const baseCritChance = 5;
        const increasedCritChance = char.baseStats?.criticalStrikeChance || 0;
        const finalCritChance = calculateCriticalStrikeChance(baseCritChance, increasedCritChance);
        const isCrit = Math.random() < (finalCritChance / 100);
        const roleDmg = 25;
        const baseDamage = Math.floor(roleDmg * (1 + strength / 150) * (bloodlustActive ? 1.3 : 1));
        const finalDamage = isCrit ? Math.floor(baseDamage * 1.5) : baseDamage;
        
        let totalDamageDealt = 0;
        
        if (aliveEnemies.length > 0) {
          // AOE damage for healer
          aliveEnemies.forEach(enemy => {
            enemy.health = Math.max(0, enemy.health - finalDamage);
            totalDamageDealt += finalDamage;
            setEnemyFightAnims(prev => ({ ...prev, [enemy.id]: (prev[enemy.id] || 0) + 1 })); // Trigger enemy hit animation
          });
          member.totalDamage = (member.totalDamage || 0) + totalDamageDealt;
        
          const jitterX = (Math.random() * 80) - 40;
          const jitterY = (Math.random() * 60) - 30;
          if (isCrit) setScreenShake(prev => prev + 1);
          setTeamFightAnim(prev => prev + 1); // Trigger team fighting animation
          const floatNum = createFloatingNumber(
            totalDamageDealt,
            isCrit ? 'crit' : 'player',
            currentCombatState.teamPosition.x + jitterX,
            currentCombatState.teamPosition.y - 40 + jitterY
          );
          updateCombatState(prev => ({ 
            ...prev, 
            floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum],
            combatLog: [...prev.combatLog, { 
              timestamp: totalTime, 
              type: 'damage', 
              source: char.name, 
              target: aliveEnemies.length > 1 ? `${aliveEnemies.length} enemies` : aliveEnemies[0].name, 
              value: totalDamageDealt, 
              message: `‚ú® ${char.name} Holy Nova hits ${aliveEnemies.length > 1 ? aliveEnemies.length + ' enemies' : aliveEnemies[0].name} for ${finalDamage}${isCrit ? ' CRIT!' : ''} each!` 
            }] 
          }));
        }
        member.gcdEndTime = Date.now() + 1500; // 1.5s GCD
      });
      
      // Apply batched DPS damage updates
      if (dpsFloatNumbers.length > 0 || dpsLogEntries.length > 0) {
        updateCombatState(prev => ({
          ...prev,
          floatingNumbers: [...prev.floatingNumbers.slice(-20), ...dpsFloatNumbers].slice(-20),
          combatLog: [...prev.combatLog, ...dpsLogEntries]
        }));
      }
      
      // Check for newly dead enemies and mark them, award experience
      currentEnemies.forEach(enemy => {
        if (enemy.health <= 0 && !enemy.isDead) {
          enemy.isDead = true;
          enemy.deathTime = Date.now();
          
          // Award experience to all alive team members (shared exp)
          if (!experienceAwarded.has(enemy.id)) {
            experienceAwarded.add(enemy.id);
            
            // Get enemy definition to calculate exp
            const enemyDef = getEnemyById(enemy.enemyId);
            if (enemyDef) {
              // Award experience to all alive team members (calculated per character based on their level)
              const aliveTeamMembers = teamStates.filter(m => !m.isDead);
              aliveTeamMembers.forEach(member => {
                const character = team.find(c => c.id === member.id);
                if (character) {
                  // Calculate experience based on this character's level (for level difference penalty)
                  const expGained = calculateExperienceFromEnemy(enemyDef, selectedKeyLevel, scaling.healthMultiplier, character.level);
                  
                  const levelUpResult = awardExperience(character.id, expGained);
                  if (levelUpResult && levelUpResult.leveledUp) {
                    // Add level up animation to state (will be displayed on character frame)
                    updateCombatState(prev => ({ 
                      ...prev, 
                      levelUpAnimations: [...prev.levelUpAnimations, {
                        characterId: character.id,
                        newLevel: levelUpResult.newLevel,
                        timestamp: Date.now()
                      }],
                      combatLog: [...prev.combatLog, { 
                        timestamp: totalTime, 
                        type: 'level', 
                        source: character.name, 
                        target: '', 
                        message: `üéâ ${character.name} reached level ${levelUpResult.newLevel}!` 
                      }] 
                    }));
                  }
                }
              });
              
              updateCombatState(prev => ({ 
                ...prev, 
                combatLog: [...prev.combatLog, { 
                  timestamp: totalTime, 
                  type: 'death', 
                  source: '', 
                  target: enemy.name, 
                  message: `‚≠ê ${enemy.name} defeated!` 
                }] 
              }));
            } else {
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: enemy.name, message: `‚≠ê ${enemy.name} defeated!` }] }));
            }
          } else {
            updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: enemy.name, message: `‚≠ê ${enemy.name} defeated!` }] }));
          }
        }
      });
      
      // Persist updated enemy states (including dead enemies for animation)
      // Keep dead enemies for 800ms after death for animation
      const now = Date.now();
      const enemiesToKeep = currentEnemies.filter(e => 
        e.health > 0 || (e.isDead && e.deathTime && (now - e.deathTime) < 800)
      );
      
      currentEnemies = enemiesToKeep.length > 0 
        ? enemiesToKeep.map(e => ({ ...e }))
        : aliveEnemies.map(e => ({ ...e }));
      
      teamStates = teamStates.map(m => ({ ...m }));
      
      updateCombatState(prev => ({ ...prev, enemies: currentEnemies, teamStates: [...teamStates], abilities: [...abilities], bloodlustActive, bloodlustTimer, timeElapsed: totalTime }));
    }

    const pullForces = packs.reduce((sum, p) => sum + p.totalForces, 0);
    totalForcesCleared += pullForces;
    
    updateCombatState(prev => ({
      ...prev, forcesCleared: totalForcesCleared, enemies: [], teamStates,
      combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'loot', source: '', target: '', message: `‚úÖ Pull complete! +${pullForces} forces` }]
    }));

    await sleep(300);
    
    // Stop all current casts before post-combat recovery
    teamStates = teamStates.map(m => ({
      ...m,
      isCasting: false,
      castStartTime: undefined,
      castTotalTime: undefined,
      castAbility: undefined,
      castTargetId: undefined
    }));
    updateCombatState(prev => ({ ...prev, teamStates: [...teamStates] }));
    
    // Post-combat recovery phase - healer casts heals and drinks
    const healer = teamStates.find(m => m.role === 'healer' && !m.isDead);
    if (healer && !combatRef.current.stop) {
      const aliveMembers = teamStates.filter(m => !m.isDead);
      const membersNeedingHealing = aliveMembers.filter(m => m.health < m.maxHealth);
      
      // Phase 1: Healer casts heals on injured party members until everyone is full health
      let firstHealMessage = true;
      while (membersNeedingHealing.length > 0 && !combatRef.current.stop && !timedOut) {
        if (firstHealMessage) {
          updateCombatState(prev => ({ ...prev, phase: 'traveling', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: healer.name, target: '', message: `ü©∏ ${healer.name} is healing up the party...` }] }));
          firstHealMessage = false;
        }
        
        // Find the most injured member
        const injured = membersNeedingHealing.reduce((mostInjured, m) => {
          const injuredPercent = (mostInjured.maxHealth - mostInjured.health) / mostInjured.maxHealth;
          const mPercent = (m.maxHealth - m.health) / m.maxHealth;
          return mPercent > injuredPercent ? m : mostInjured;
        });
        
        if (combatRef.current.stop) break;
        if (checkTimeout()) { timedOut = true; break; }
        
        const healNeeded = injured.maxHealth - injured.health;
        const healAmount = Math.min(healNeeded, Math.floor(injured.maxHealth * 0.4)); // Heal for 40% max HP per cast
        const castTime = 1.2;
        
        // Set healer casting state
        healer.isCasting = true;
        healer.castAbility = 'Healing Wave';
        healer.castStartTime = Date.now();
        healer.castTotalTime = castTime;
        healer.castTargetId = injured.id;
        
        // Update combat state to show casting
        teamStates = teamStates.map(m => 
          m.id === healer.id 
            ? { ...m, isCasting: true, castAbility: 'Healing Wave', castStartTime: healer.castStartTime, castTotalTime: castTime, castTargetId: injured.id }
            : m
        );
        updateCombatState(prev => ({ ...prev, teamStates: [...teamStates] }));
        
        // Animate the cast - wait for actual cast time
        const castStartTime = Date.now();
        while (Date.now() - castStartTime < castTime * 1000) {
          if (combatRef.current.stop) break;
          await sleep(7);
          totalTime += 0.007;
          // Update combat state periodically to keep UI responsive
          if (Math.floor((Date.now() - castStartTime) / 50) !== Math.floor((Date.now() - castStartTime - 10) / 50)) {
            updateCombatState(prev => ({ ...prev, teamStates: [...teamStates], timeElapsed: totalTime }));
          }
        }
        
        // Apply the heal
        const healerChar = team.find(c => c.id === healer.id);
        const critChance = healerChar?.baseStats?.critChance || 10;
        const isCritHeal = Math.random() < (critChance / 100);
        const finalHealAmount = isCritHeal ? Math.floor(healAmount * 1.5) : healAmount;
        const actualHeal = Math.min(injured.maxHealth - injured.health, finalHealAmount);
        injured.health = Math.min(injured.maxHealth, injured.health + finalHealAmount);
        const healTimestamp = Date.now();
        injured.lastHealTime = healTimestamp;
        injured.lastHealAmount = actualHeal;
        injured.lastHealCrit = isCritHeal;
        if (isCritHeal) setScreenShake(prev => prev + 1);
        healer.mana = Math.max(0, healer.mana - 16);
        healer.totalHealing = (healer.totalHealing || 0) + actualHeal;
        healer.healingBySpell = healer.healingBySpell || {};
        healer.healingBySpell['Healing Wave'] = (healer.healingBySpell['Healing Wave'] || 0) + actualHeal;
        healer.isCasting = false;
        
        // Show floating heal number
        const jitterX = (Math.random() * 80) - 40;
        const jitterY = (Math.random() * 60) - 30;
        const floatNum = createFloatingNumber(actualHeal, 'heal', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 50 + jitterY);
        
        // Update teamStates with the healed member
        teamStates = teamStates.map(m => 
          m.id === injured.id 
            ? { ...m, lastHealTime: healTimestamp, lastHealAmount: actualHeal, lastHealCrit: isCritHeal, health: injured.health }
            : m.id === healer.id
            ? { ...m, mana: healer.mana, totalHealing: healer.totalHealing, healingBySpell: healer.healingBySpell, isCasting: false }
            : m
        );
        
        updateCombatState(prev => ({ 
          ...prev, 
          teamStates: [...teamStates],
          timeElapsed: totalTime,
          floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum],
          combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'heal', source: healer.name, target: injured.name, value: actualHeal, message: `üíä ${healer.name} casts Healing Wave on ${injured.name} for ${actualHeal}${isCritHeal ? ' CRIT!' : ''}!` }]
        }));
        
        // Update the list of members needing healing
        const updatedAliveMembers = teamStates.filter(m => !m.isDead);
        membersNeedingHealing.length = 0;
        membersNeedingHealing.push(...updatedAliveMembers.filter(m => m.health < m.maxHealth));
        
        // If healer is out of mana, break and let them drink
        if (healer.mana < 16) break;
      }
      
      // Phase 2: Healer drinks to restore mana
      if (healer.mana < healer.maxMana * 0.8 && !combatRef.current.stop && !timedOut) {
        const drinkTime = Math.ceil((1 - healer.mana / healer.maxMana) * 4); // Up to 4 seconds drinking
        const manaPerTick = Math.ceil((healer.maxMana - healer.mana) / (drinkTime * 100));
        
        updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: healer.name, target: '', message: `ü•§ ${healer.name} is drinking...` }] }));
        
        for (let t = 1; t <= drinkTime * 100; t++) {
          if (combatRef.current.stop) break;
          if (checkTimeout()) { timedOut = true; break; }
          
          await sleep(7);
          totalTime += 0.007;
          
          healer.mana = Math.min(healer.maxMana, healer.mana + manaPerTick);
          
          // Also regen mana for others while waiting
          teamStates = teamStates.map(m => {
            if (m.isDead || m.role === 'healer') return m;
            return { ...m, mana: Math.min(m.maxMana, m.mana + Math.floor(m.maxMana * 0.02)) };
          });
          
          updateCombatState(prev => ({ 
            ...prev, 
            teamStates: [...teamStates],
            timeElapsed: totalTime
          }));
        }
        
        updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'buff', source: healer.name, target: '', message: `‚ú® ${healer.name} finished drinking. Ready!` }] }));
        
        // After drinking, continue healing if anyone still needs it
        const updatedAliveMembers = teamStates.filter(m => !m.isDead);
        let stillNeedingHealing = updatedAliveMembers.filter(m => m.health < m.maxHealth);
        
        while (stillNeedingHealing.length > 0 && !combatRef.current.stop && !timedOut) {
          // Find the most injured member
          const injured = stillNeedingHealing.reduce((mostInjured, m) => {
            const injuredPercent = (mostInjured.maxHealth - mostInjured.health) / mostInjured.maxHealth;
            const mPercent = (m.maxHealth - m.health) / m.maxHealth;
            return mPercent > injuredPercent ? m : mostInjured;
          });
          
          if (combatRef.current.stop) break;
          if (checkTimeout()) { timedOut = true; break; }
          
          const healNeeded = injured.maxHealth - injured.health;
          const healAmount = Math.min(healNeeded, Math.floor(injured.maxHealth * 0.4));
          const castTime = 1.2;
          
          // Set healer casting state
          healer.isCasting = true;
          healer.castAbility = 'Healing Wave';
          healer.castStartTime = Date.now();
          healer.castTotalTime = castTime;
          healer.castTargetId = injured.id;
          
          // Update combat state to show casting
          teamStates = teamStates.map(m => 
            m.id === healer.id 
              ? { ...m, isCasting: true, castAbility: 'Healing Wave', castStartTime: healer.castStartTime, castTotalTime: castTime, castTargetId: injured.id }
              : m
          );
          updateCombatState(prev => ({ ...prev, teamStates: [...teamStates] }));
          
          // Animate the cast - wait for actual cast time
          const castStartTime = Date.now();
          while (Date.now() - castStartTime < castTime * 1000) {
            if (combatRef.current.stop) break;
            await sleep(7);
            totalTime += 0.007;
            // Update combat state periodically to keep UI responsive
            if (Math.floor((Date.now() - castStartTime) / 50) !== Math.floor((Date.now() - castStartTime - 10) / 50)) {
              updateCombatState(prev => ({ ...prev, teamStates: [...teamStates], timeElapsed: totalTime }));
            }
          }
          
          // Apply the heal
          const healerChar = team.find(c => c.id === healer.id);
          const critChance = healerChar?.baseStats?.critChance || 10;
          const isCritHeal = Math.random() < (critChance / 100);
          const finalHealAmount = isCritHeal ? Math.floor(healAmount * 1.5) : healAmount;
          const actualHeal = Math.min(injured.maxHealth - injured.health, finalHealAmount);
          injured.health = Math.min(injured.maxHealth, injured.health + finalHealAmount);
          const healTimestamp = Date.now();
          injured.lastHealTime = healTimestamp;
          injured.lastHealAmount = actualHeal;
          injured.lastHealCrit = isCritHeal;
          if (isCritHeal) setScreenShake(prev => prev + 1);
          healer.mana = Math.max(0, healer.mana - 16);
          healer.totalHealing = (healer.totalHealing || 0) + actualHeal;
          healer.healingBySpell = healer.healingBySpell || {};
          healer.healingBySpell['Healing Wave'] = (healer.healingBySpell['Healing Wave'] || 0) + actualHeal;
          healer.isCasting = false;
          
          // Show floating heal number
          const jitterX = (Math.random() * 80) - 40;
          const jitterY = (Math.random() * 60) - 30;
          const floatNum = createFloatingNumber(actualHeal, 'heal', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 50 + jitterY);
          
          // Update teamStates
          teamStates = teamStates.map(m => 
            m.id === injured.id 
              ? { ...m, lastHealTime: healTimestamp, lastHealAmount: actualHeal, lastHealCrit: isCritHeal, health: injured.health }
              : m.id === healer.id
              ? { ...m, mana: healer.mana, totalHealing: healer.totalHealing, healingBySpell: healer.healingBySpell, isCasting: false }
              : m
          );
          
          updateCombatState(prev => ({ 
            ...prev, 
            teamStates: [...teamStates],
            timeElapsed: totalTime,
            floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum],
            combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'heal', source: healer.name, target: injured.name, value: actualHeal, message: `üíä ${healer.name} casts Healing Wave on ${injured.name} for ${actualHeal}${isCritHeal ? ' CRIT!' : ''}!` }]
          }));
          
          // Update the list of members needing healing
          const refreshedAliveMembers = teamStates.filter(m => !m.isDead);
          stillNeedingHealing = refreshedAliveMembers.filter(m => m.health < m.maxHealth);
          
          // If healer is out of mana again, break (shouldn't happen after drinking, but safety check)
          if (healer.mana < 16) break;
        }
      }
      
      if (timedOut) {
        updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: '‚è∞ TIME EXPIRED during recovery! Dungeon failed.' }] }));
        setIsRunning(false);
        return null;
      }
    }
    
    // Final top-off to ensure everyone is full (only if healer couldn't finish)
    teamStates = teamStates.map(m => ({
      ...m,
      health: m.isDead ? m.health : Math.min(m.maxHealth, m.health), // Don't exceed max, but ensure full if alive
      mana: m.isDead ? m.mana : m.maxMana,
      gcdRemaining: 0,
      gcdEndTime: undefined,
      isCasting: false,
      castStartTime: undefined,
      castTotalTime: undefined,
      castAbility: undefined,
      castTargetId: undefined
    }));
    
    // Ensure all alive members are at full health
    teamStates = teamStates.map(m => ({
      ...m,
      health: m.isDead ? m.health : m.maxHealth
    }));

    // Check if any team members died - healer must resurrect before continuing
    const deadMembers = teamStates.filter(m => m.isDead);
    if (deadMembers.length > 0) {
      const healer = teamStates.find(m => m.role === 'healer' && !m.isDead);
      
      if (!healer) {
        // No healer alive to resurrect - WIPE
        updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: 'üíÄ WIPE! Healer is dead and cannot resurrect the party.' }] }));
        setIsRunning(false);
        return null;
      }

      // Healer casts Mass Resurrection (6 second cast)
      const rezCastTime = 6;
      updateCombatState(prev => ({ 
        ...prev, 
        phase: 'traveling',
        combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: healer.name, target: '', message: `üôè ${healer.name} begins casting Mass Resurrection... (${rezCastTime}s)` }]
      }));

      // Animate the resurrection cast - 6 second cast with 10ms ticks
      const rezCastTicks = Math.ceil(rezCastTime * 100); // 100 ticks per second
      for (let i = 1; i <= rezCastTicks; i++) {
        if (combatRef.current.stop) break;
        if (checkTimeout()) {
          timedOut = true;
          break;
        }
        await sleep(7);
        totalTime += 0.007;
        
        // Update time display during rez cast
        updateCombatState(prev => ({ 
          ...prev, 
          timeElapsed: totalTime,
          healerCasting: { ability: 'Mass Resurrection', progress: (i / rezCastTicks) * 100, startTime: i === 1 ? Date.now() : prev.healerCasting?.startTime || Date.now() }
        }));
      }

      if (combatRef.current.stop) {
        setIsRunning(false);
        return null;
      }

      if (timedOut) {
        updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: '‚è∞ TIME EXPIRED during resurrection! Dungeon failed.' }] }));
        setIsRunning(false);
        return null;
      }

      // Resurrect all dead members at 50% health
      teamStates = teamStates.map(m => ({
        ...m,
        isDead: false,
        health: m.isDead ? Math.floor(m.maxHealth * 0.5) : m.health,
        gcdRemaining: 0
      }));

      const rezNames = deadMembers.map(m => m.name).join(', ');
      updateCombatState(prev => ({ 
        ...prev, 
        teamStates,
        healerCasting: undefined,
        combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'heal', source: healer.name, target: rezNames, message: `‚ú® ${healer.name} resurrects ${rezNames}!` }]
      }));

      await sleep(500);
    }
  }

  // Check if stopped after main pull loop
  if (combatRef.current.stop) {
    setIsRunning(false);
    return null;
  }

  // Final Boss
  const boss = dungeon.bosses[0];
  if (boss && teamStates.some(m => !m.isDead) && !timedOut && !combatRef.current.stop) {
    // Travel to boss
    const bossDistance = Math.sqrt(Math.pow(boss.position.x - currentPos.x, 2) + Math.pow(boss.position.y - currentPos.y, 2));
    const bossTravelTime = Math.max(2, Math.min(6, Math.floor(bossDistance / 200)));
    
    updateCombatState(prev => ({ ...prev, phase: 'traveling', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'travel', source: '', target: '', message: `üö∂ Approaching the Final Boss... (${bossTravelTime}s)` }] }));
    
    for (let i = 1; i <= 15; i++) {
      if (combatRef.current.stop || checkTimeout()) break;
      await sleep((bossTravelTime * 1000) / 15);
      totalTime += bossTravelTime / 15;
      const newX = currentPos.x + (boss.position.x - currentPos.x) * (i / 15);
      const newY = currentPos.y + (boss.position.y - currentPos.y) * (i / 15);
      updateCombatState(prev => ({ ...prev, teamPosition: { x: newX, y: newY }, timeElapsed: totalTime }));
    }
    
    // Check if stopped during boss travel
    if (combatRef.current.stop) {
      setIsRunning(false);
      return null;
    }
    
    if (timedOut) {
      updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: '‚è∞ TIME EXPIRED! Dungeon failed.' }] }));
      setIsRunning(false);
      return null;
    }
    
    const bossEnemy: AnimatedEnemy = {
      id: 'final_boss', enemyId: boss.enemy.id, name: boss.enemy.name, icon: boss.enemy.icon,
      type: boss.enemy.type, behavior: 'caster',
      health: boss.enemy.baseHealth * scaling.healthMultiplier * 0.5,
      maxHealth: boss.enemy.baseHealth * scaling.healthMultiplier * 0.5,
      damage: boss.enemy.baseDamage * scaling.damageMultiplier * 0.5 * 0.2 * 2 * 2, // double boss damage again
      isCasting: false, castProgress: 0, autoAttackTimer: Math.random() * 0.6 + 0.1
    };

    updateCombatState(prev => ({
      ...prev, phase: 'combat', enemies: [bossEnemy],
      combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'boss', source: '', target: '', message: `üëë FINAL BOSS: ${boss.enemy.name}!` }]
    }));

    let bossHealth = bossEnemy.health;
    let phase = 1;
    
    // Boss ability cooldowns
    let bossSlamCooldown = 0; // 0s cd (auto attack)
    let bossPulseTimer = 0; // Pulse every 3 seconds
    let bossTankBusterCooldown = 0; // 12s cd
    let bossVolleyCooldown = 0; // 5s cd
    let bossVolleyCasting = false;
    let bossVolleyCastStartTime = 0;
    const BOSS_VOLLEY_CAST_TIME = 1.5; // 1.5s cast time

    while (bossHealth > 0 && teamStates.some(m => !m.isDead) && !timedOut) {
      if (combatRef.current.stop) break;
      
      // Pause check - wait while paused
      while (combatRef.current.paused && !combatRef.current.stop) {
        await sleep(100);
      }
      if (combatRef.current.stop) break;
      
      if (checkTimeout()) {
        updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: '‚è∞ TIME EXPIRED! Dungeon failed.' }] }));
        break;
      }
      
      // Wait 7ms (roughly 143 ticks per second for smooth timing)
      const TICK_DURATION = 0.007; // seconds (7ms)
      await sleep(7);
      totalTime += TICK_DURATION;
      
      // Check for wipe
      if (!teamStates.some(m => !m.isDead)) {
        updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: 'üíÄ WIPE! Your party has been defeated.' }] }));
        
        // Find what killed teammates - look for recent damage entries targeting team members
        const teamMemberNames = teamStates.map(m => m.name);
        const deathCauses: Record<string, string> = {};
        const recentDamage = currentCombatState.combatLog
          .filter(entry => entry.type === 'damage' && teamMemberNames.includes(entry.target))
          .slice(-20); // Last 20 damage entries
        
        teamStates.forEach(member => {
          if (member.isDead) {
            // Find the last damage entry for this member
            const lastDamage = recentDamage
              .filter(entry => entry.target === member.name)
              .sort((a, b) => b.timestamp - a.timestamp)[0];
            if (lastDamage) {
              deathCauses[member.name] = lastDamage.source || 'Unknown';
            }
          }
        });
        
        // Generate reduced loot for wipe (scales with key level and progress made)
        const progressPercent = totalForcesCleared / dungeon.requiredForces;
        const wipeLootCount = Math.max(1, Math.floor(progressPercent * 3) + Math.floor(selectedKeyLevel / 5));
        const loot = generateDungeonLoot(selectedKeyLevel, false, 0, scaling.itemQuantity, scaling.itemRarity).slice(0, wipeLootCount);
        const orbDrops = generateOrbDrops(selectedKeyLevel, false, progressPercent);
        const xp = Math.floor(200 * scaling.rewardMultiplier * progressPercent);
        
        const result: DungeonRunResult = {
          success: false, keyLevel: selectedKeyLevel, timeElapsed: totalTime, timeLimit: dungeon.timeLimitSeconds,
          upgradeLevel: 0, loot, orbDrops, experienceGained: xp, deaths: teamStates.filter(m => m.isDead).length,
          forcesCleared: totalForcesCleared, forcesRequired: dungeon.requiredForces, combatLog: currentCombatState.combatLog,
          failReason: 'wipe',
          failedPullIndex: currentCombatState.currentPullIndex,
          deathCauses
        };
        
        addOrbs(orbDrops);
        setRunResult(result);
        setIsRunning(false);
        return result;
      }
      
      abilities = abilities.map(a => ({ ...a, currentCooldown: Math.max(0, a.currentCooldown - TICK_DURATION) }));
      if (bloodlustActive) { bloodlustTimer -= TICK_DURATION; if (bloodlustTimer <= 0) bloodlustActive = false; }
      
      // Update boss cooldowns
      bossSlamCooldown = Math.max(0, bossSlamCooldown - TICK_DURATION);
      bossPulseTimer -= TICK_DURATION;
      bossTankBusterCooldown = Math.max(0, bossTankBusterCooldown - TICK_DURATION);
      bossVolleyCooldown = Math.max(0, bossVolleyCooldown - TICK_DURATION);

      // Check for resurrection requests from useAbility
      if (combatRef.current.resurrectRequest) {
        const rezTargetId = combatRef.current.resurrectRequest;
        teamStates = teamStates.map(m => 
          m.id === rezTargetId 
            ? { ...m, isDead: false, health: Math.floor(m.maxHealth * 0.6), mana: Math.floor(m.maxMana * 0.3), lastResurrectTime: Date.now() } 
            : m
        );
        combatRef.current.resurrectRequest = null;
      }
      
      // Check for bloodlust activation from useAbility
      if (combatRef.current.bloodlustRequest) {
        bloodlustActive = true;
        bloodlustTimer = 15;
        combatRef.current.bloodlustRequest = false;
      }
      
      // Sync ability cooldowns from ref (when player clicks abilities)
      Object.entries(combatRef.current.abilityCooldowns).forEach(([id, cd]) => {
        const ability = abilities.find(a => a.id === id);
        if (ability && cd > ability.currentCooldown) {
          ability.currentCooldown = cd;
        }
      });
      combatRef.current.abilityCooldowns = {};

      // Boss abilities (only if not stunned)
      if (!stunActive) {
        const tank = teamStates.find(m => m.role === 'tank' && !m.isDead);
        const aliveMembers = teamStates.filter(m => !m.isDead);
        
        // Pulse (aura - damages everyone periodically, doesn't prevent other abilities)
        if (bossPulseTimer <= 0) {
          bossPulseTimer = 3; // Reset to 3 seconds
          const pulseDamage = Math.floor(bossEnemy.damage * 0.7 * 0.7); // Current pulse damage minus 30%
          
          for (const member of aliveMembers) {
            const effectiveArmor = member.armor * (1 + (member.armorBuff || 0) / 100);
            const painSuppMult = member.damageReduction ? (1 - member.damageReduction / 100) : 1;
            // PoE armor formula
            const armorMult = calculateArmorReduction(effectiveArmor, pulseDamage);
            let dmg = Math.floor(pulseDamage * armorMult * painSuppMult);
            const blockChance = (member.blockChance || 0) + (member.blockBuff || 0);
            const blocked = rollBlock(blockChance);
            if (blocked) {
              dmg = Math.floor(dmg * (1 - BLOCK_DAMAGE_REDUCTION));
              member.lastBlockTime = Date.now();
            }
            member.health = Math.max(0, member.health - dmg);
            member.recentDamageTaken = (member.recentDamageTaken || 0) + dmg;
            const jitterX = (Math.random() * 80) - 40;
            const jitterY = (Math.random() * 60) - 30;
            const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
            updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: boss.enemy.name, target: member.name, value: dmg, message: `üíÄ ${boss.enemy.name}'s Pulse hits ${member.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
            if (member.health <= 0) {
              member.isDead = true;
              updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: member.name, message: `üíÄ ${member.name} has died!` }] }));
            }
          }
        }
        
        // Check if Volley cast is complete
        if (bossVolleyCasting && bossVolleyCastStartTime > 0) {
          const elapsedMs = Date.now() - bossVolleyCastStartTime;
          if (elapsedMs >= (BOSS_VOLLEY_CAST_TIME * 1000)) {
            // Volley completes - hits all teammates
            const volleyDamage = Math.floor(bossEnemy.damage * 0.4); // Medium-low damage
            
            for (const member of aliveMembers) {
              const effectiveArmor = member.armor * (1 + (member.armorBuff || 0) / 100);
              const painSuppMult = member.damageReduction ? (1 - member.damageReduction / 100) : 1;
              // PoE armor formula
              const armorMult = calculateArmorReduction(effectiveArmor, volleyDamage);
              let dmg = Math.floor(volleyDamage * armorMult * painSuppMult);
              const blockChance = (member.blockChance || 0) + (member.blockBuff || 0);
              const blocked = rollBlock(blockChance);
              if (blocked) {
                dmg = Math.floor(dmg * (1 - BLOCK_DAMAGE_REDUCTION));
                member.lastBlockTime = Date.now();
              }
              member.health = Math.max(0, member.health - dmg);
              member.recentDamageTaken = (member.recentDamageTaken || 0) + dmg;
              const jitterX = (Math.random() * 80) - 40;
              const jitterY = (Math.random() * 60) - 30;
              const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
              updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: boss.enemy.name, target: member.name, value: dmg, message: `‚ö° ${boss.enemy.name}'s Volley hits ${member.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
              if (member.health <= 0) {
                member.isDead = true;
                updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: member.name, message: `üíÄ ${member.name} has died!` }] }));
              }
            }
            
            bossVolleyCasting = false;
            bossVolleyCastStartTime = 0;
            bossVolleyCooldown = 5; // Reset cooldown
            updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: boss.enemy.name, target: '', message: `‚ö° ${boss.enemy.name} unleashes Volley on the party!` }] }));
          }
        }
        
        // Tank Buster (12s cooldown, hits tank very hard)
        if (bossTankBusterCooldown <= 0 && tank && !bossVolleyCasting) {
          bossTankBusterCooldown = 12;
          const effectiveArmor = tank.armor * (1 + (tank.armorBuff || 0) / 100);
          const painSuppMult = tank.damageReduction ? (1 - tank.damageReduction / 100) : 1;
          const rawTankBusterDamage = bossEnemy.damage * 3.0; // Very hard hit
          // PoE armor formula
          const armorMult = calculateArmorReduction(effectiveArmor, rawTankBusterDamage);
          let dmg = Math.floor(rawTankBusterDamage * armorMult * painSuppMult);
          const blockChance = (tank.blockChance || 0) + (tank.blockBuff || 0);
          const blocked = rollBlock(blockChance);
          if (blocked) {
            dmg = Math.floor(dmg * (1 - BLOCK_DAMAGE_REDUCTION));
            tank.lastBlockTime = Date.now();
          }
          tank.health = Math.max(0, tank.health - dmg);
          tank.recentDamageTaken = (tank.recentDamageTaken || 0) + dmg;
          const jitterX = (Math.random() * 80) - 40;
          const jitterY = (Math.random() * 60) - 30;
          const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
          updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: boss.enemy.name, target: tank.name, value: dmg, message: `üí• ${boss.enemy.name}'s Tank Buster hits ${tank.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
          if (tank.health <= 0) {
            tank.isDead = true;
            updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: tank.name, message: `üíÄ ${tank.name} has died!` }] }));
          }
        }
        
        // Volley (5s cooldown, 1.5s cast time, hits all teammates)
        if (bossVolleyCooldown <= 0 && !bossVolleyCasting && bossTankBusterCooldown > 0) {
          bossVolleyCasting = true;
          bossVolleyCastStartTime = Date.now();
          updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'ability', source: boss.enemy.name, target: '', message: `‚ö° ${boss.enemy.name} begins casting Volley...` }] }));
        }
        
        // Slam (auto attack - 0s cd, 0s cast time, hits tank moderately)
        if (bossSlamCooldown <= 0 && tank && !bossVolleyCasting) {
          bossSlamCooldown = 2.0; // Auto attack every 2 seconds
          const effectiveArmor = tank.armor * (1 + (tank.armorBuff || 0) / 100);
          const painSuppMult = tank.damageReduction ? (1 - tank.damageReduction / 100) : 1;
          const rawSlamDamage = bossEnemy.damage * 1.2; // Moderate hit
          // PoE armor formula
          const armorMult = calculateArmorReduction(effectiveArmor, rawSlamDamage);
          let dmg = Math.floor(rawSlamDamage * armorMult * painSuppMult);
          const blockChance = (tank.blockChance || 0) + (tank.blockBuff || 0);
          const blocked = rollBlock(blockChance);
          if (blocked) {
            dmg = Math.floor(dmg * (1 - BLOCK_DAMAGE_REDUCTION));
            tank.lastBlockTime = Date.now();
          }
          tank.health = Math.max(0, tank.health - dmg);
          tank.recentDamageTaken = (tank.recentDamageTaken || 0) + dmg;
          const jitterX = (Math.random() * 80) - 40;
          const jitterY = (Math.random() * 60) - 30;
          const floatNum = createFloatingNumber(dmg, blocked ? 'blocked' : 'enemy', currentCombatState.teamPosition.x + jitterX, currentCombatState.teamPosition.y - 40 + jitterY);
          updateCombatState(prev => ({ ...prev, floatingNumbers: [...prev.floatingNumbers.slice(-20), floatNum], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'damage', source: boss.enemy.name, target: tank.name, value: dmg, message: `üí¢ ${boss.enemy.name}'s Slam hits ${tank.name} for ${dmg}${blocked ? ' (BLOCKED!)' : ''}!` }] }));
          if (tank.health <= 0) {
            tank.isDead = true;
            updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'death', source: '', target: tank.name, message: `üíÄ ${tank.name} has died!` }] }));
          }
        }
      }

      // Process buffs, HoTs, regen, and decay recent damage tracking (same as regular combat)
      teamStates = teamStates.map(m => {
        if (m.isDead) return m;
        
        // Base regeneration per second
        const hpRegenPerSecond = m.role === 'tank' ? m.maxHealth * 0.01 : m.maxHealth * 0.005;
        const manaRegenPerSecond = m.role === 'healer' ? m.maxMana * 0.03 : m.maxMana * 0.02;
        
        // Apply regeneration scaled by tick (don't exceed max)
        const hpRegenAmount = hpRegenPerSecond * TICK_DURATION;
        const manaRegenAmount = manaRegenPerSecond * TICK_DURATION;
        
        // Decay damage reduction duration (Pain Suppression) - use TICK_DURATION
        let newDmgReduction = m.damageReduction || 0;
        let newDmgReductionDuration = (m.damageReductionDuration || 0) - TICK_DURATION;
        if (newDmgReductionDuration <= 0) {
          newDmgReduction = 0;
          newDmgReductionDuration = 0;
        }
        
        // Decay armor buff duration (Defensive Stance) - use TICK_DURATION
        let newArmorBuff = m.armorBuff || 0;
        let newArmorBuffDuration = (m.armorBuffDuration || 0) - TICK_DURATION;
        if (newArmorBuffDuration <= 0) {
          newArmorBuff = 0;
          newArmorBuffDuration = 0;
        }
        
        // Decay block buff duration (Shield Block) - use TICK_DURATION
        let newBlockBuff = m.blockBuff || 0;
        let newBlockBuffDuration = (m.blockBuffDuration || 0) - TICK_DURATION;
        if (newBlockBuffDuration <= 0) {
          newBlockBuff = 0;
          newBlockBuffDuration = 0;
        }
        
        // Decay recent damage taken (scaled by tick - decay slower with faster ticks)
        const decayFactor = Math.pow(0.5, TICK_DURATION); // decay per tick at 7ms
        const newRecentDamage = Math.floor((m.recentDamageTaken || 0) * decayFactor);
        
        // Process HoT effects
        let newHealth = Math.min(m.maxHealth, m.health + hpRegenAmount);
        let newMana = Math.min(m.maxMana, m.mana + manaRegenAmount);
        let newHotEffects = (m.hotEffects || []).map(hot => {
          let updatedHot = { ...hot, remainingDuration: hot.remainingDuration - TICK_DURATION, nextTickIn: hot.nextTickIn - TICK_DURATION };
          if (updatedHot.nextTickIn <= 0 && updatedHot.remainingDuration > 0) {
            const healAmount = hot.healPerTick;
            const hotHealerChar = team.find(c => c.id === hot.sourceId);
            const critChance = hotHealerChar?.baseStats?.criticalStrikeChance || 10;
            const isCritHeal = Math.random() < (critChance / 100);
            const finalHealAmount = isCritHeal ? Math.floor(healAmount * 1.5) : healAmount;
            const actualHeal = Math.min(m.maxHealth - newHealth, finalHealAmount);
            newHealth = Math.min(m.maxHealth, newHealth + finalHealAmount);
            updatedHot.nextTickIn = hot.tickInterval;
            const hotHealTimestamp = Date.now();
            m.lastHealTime = hotHealTimestamp;
            m.lastHealAmount = actualHeal;
            m.lastHealCrit = isCritHeal;
            if (isCritHeal) setScreenShake(prev => prev + 1);
          }
          return updatedHot;
        }).filter(hot => hot.remainingDuration > 0);
        
        return { 
          ...m, 
          health: newHealth,
          mana: newMana,
          damageReduction: newDmgReduction, 
          damageReductionDuration: newDmgReductionDuration,
          armorBuff: newArmorBuff,
          armorBuffDuration: newArmorBuffDuration,
          blockBuff: newBlockBuff,
          blockBuffDuration: newBlockBuffDuration,
          recentDamageTaken: newRecentDamage,
          hotEffects: newHotEffects
        };
      });

      // Healer casting logic (same as regular combat)
      const healer = teamStates.find(m => m.role === 'healer' && !m.isDead);
      if (healer && healer.mana > 0) {
        const aliveMembers = teamStates.filter(m => !m.isDead);
        const hurtMembers = aliveMembers.filter(m => m.health < m.maxHealth * 0.95);
        
        if (hurtMembers.length > 0) {
          // If currently casting, check if cast is complete
          if (healer.isCasting && healer.castStartTime && healer.castTotalTime) {
            const elapsedMs = Date.now() - healer.castStartTime;
            const castComplete = elapsedMs >= (healer.castTotalTime * 1000);
            
            if (castComplete) {
              const targetId = healer.castTargetId;
              const target = teamStates.find(m => m.id === targetId && !m.isDead);
              if (target) {
                const healAmount = Math.floor(target.maxHealth * 0.4);
                const healerChar = team.find(c => c.id === healer.id);
                const critChance = healerChar?.baseStats?.criticalStrikeChance || 10;
                const isCritHeal = Math.random() < (critChance / 100);
                const finalHealAmount = isCritHeal ? Math.floor(healAmount * 1.5) : healAmount;
                const actualHeal = Math.min(target.maxHealth - target.health, finalHealAmount);
                target.health = Math.min(target.maxHealth, target.health + finalHealAmount);
                const healTimestamp = Date.now();
                target.lastHealTime = healTimestamp;
                target.lastHealAmount = actualHeal;
                target.lastHealCrit = isCritHeal;
                if (isCritHeal) setScreenShake(prev => prev + 1);
                healer.mana -= 4;
                healer.totalHealing = (healer.totalHealing || 0) + actualHeal;
              }
              healer.isCasting = false;
              healer.castAbility = undefined;
              healer.castTargetId = undefined;
              healer.gcdEndTime = Date.now() + 1500;
            }
          } else {
            // Not casting - start a new cast if GCD is ready
            const gcdReady = !healer.gcdEndTime || Date.now() >= healer.gcdEndTime;
            if (gcdReady) {
              const lowestHealth = hurtMembers.reduce((lowest, m) => (!lowest || m.health / m.maxHealth < lowest.health / lowest.maxHealth) ? m : lowest, null as TeamMemberState | null);
              if (lowestHealth) {
                healer.isCasting = true;
                healer.castStartTime = Date.now();
                healer.castTotalTime = 1.2;
                healer.castAbility = 'Healing Wave';
                healer.castTargetId = lowestHealth.id;
                healer.gcdEndTime = Date.now() + 1500;
              }
            }
          }
        }
      }

      // Team DPS - casting logic (same as regular combat)
      team.forEach((char) => {
        const member = teamStates.find(m => m.id === char.id);
        if (!member || member.isDead) return;
        
        // Healer should NOT attack if they are casting OR if someone needs healing
        if (char.role === 'healer') {
          if (member.isCasting) return;
          const hurtMembers = teamStates.filter(m => !m.isDead && m.health < m.maxHealth * 0.95);
          if (hurtMembers.length > 0) return;
        }
        
        // DPS spell casting logic
        if (char.role === 'dps') {
          // If currently casting, check if cast is complete
          if (member.isCasting && member.castStartTime && member.castTotalTime) {
            const elapsedMs = Date.now() - member.castStartTime;
            const castComplete = elapsedMs >= (member.castTotalTime * 1000);
            
            if (castComplete) {
                // PoE: Spell power scales with intelligence
                const spellPower = (char.baseStats?.intelligence || 20) * 5;
                const isCrit = Math.random() < ((char.baseStats?.criticalStrikeChance || 10) / 100);
              const ability = member.castAbility || 'Fireball';
              
              // Base damage - single target on boss
              const baseDmg = ability === 'Blow Up' ? 175 : ability === 'Shadow Bolt' ? 200 : 150;
              const damage = Math.floor(baseDmg * (1 + spellPower / 100) * (bloodlustActive ? 1.3 : 1));
              const finalDamage = isCrit ? Math.floor(damage * 1.5) : damage;
              
              bossHealth = Math.max(0, bossHealth - finalDamage);
              member.totalDamage = (member.totalDamage || 0) + finalDamage;
              member.damageBySpell = member.damageBySpell || {};
              member.damageBySpell[ability] = (member.damageBySpell[ability] || 0) + finalDamage;
              if (isCrit) setScreenShake(prev => prev + 1);
              
              const abilityName = ability === 'Blow Up' ? 'üí• Blow Up' : ability === 'Shadow Bolt' ? 'üåë Shadow Bolt' : 'üî• Fireball';
              updateCombatState(prev => ({ 
                ...prev, 
                combatLog: [...prev.combatLog, { 
                  timestamp: totalTime, 
                  type: 'damage', 
                  source: char.name, 
                  target: boss.enemy.name, 
                  value: finalDamage, 
                  message: `${abilityName} ${char.name} hits ${boss.enemy.name} for ${finalDamage}${isCrit ? ' CRIT!' : ''}!` 
                }] 
              }));
              
              member.isCasting = false;
              member.castAbility = undefined;
              member.castTargetId = undefined;
              member.gcdEndTime = Date.now() + 1500;
            } else {
              return; // Still casting
            }
          }
          
          // Not casting (or just finished) - start a new cast if GCD is done
          const gcdReady = !member.gcdEndTime || Date.now() >= member.gcdEndTime;
          if (gcdReady && bossHealth > 0) {
            const equippedSkillIds = char.skillGems?.map(sg => sg.skillGemId) || [];
            const hasBlowUp = equippedSkillIds.includes('blow_up');
            const hasShadowBolt = equippedSkillIds.includes('shadow_bolt');
            const hasFireball = equippedSkillIds.includes('fireball');
            
            // For boss, prefer single target spells
            let spellChoice: string;
            let castTimeSeconds: number;
            
            if (hasFireball) { spellChoice = 'Fireball'; castTimeSeconds = 1.2; }
            else if (hasShadowBolt) { spellChoice = 'Shadow Bolt'; castTimeSeconds = 1.6; }
            else if (hasBlowUp) { spellChoice = 'Blow Up'; castTimeSeconds = 1.62; }
            else { spellChoice = 'Fireball'; castTimeSeconds = 1.2; }
            
            member.isCasting = true;
            member.castProgress = Math.ceil(castTimeSeconds);
            member.castTotalTime = castTimeSeconds;
            member.castStartTime = Date.now();
            member.gcdEndTime = Date.now() + 1500;
            member.castAbility = spellChoice;
            
            updateCombatState(prev => ({ 
              ...prev, 
              combatLog: [...prev.combatLog, { 
                timestamp: totalTime, 
                type: 'ability', 
                source: char.name, 
                target: boss.enemy.name, 
                message: `üîÆ ${char.name} begins casting ${spellChoice} on ${boss.enemy.name}...` 
              }] 
            }));
          }
          return;
        }
        
        // Tank attacks (instant)
        if (char.role === 'tank') {
          const tankGcdReady = !member.gcdEndTime || Date.now() >= member.gcdEndTime;
          if (!tankGcdReady) return;
          
          // PoE: Damage scales with strength, crit chance is separate stat
          const strength = char.baseStats?.strength || 20;
          // PoE-style crit: base crit chance * (1 + increased crit chance / 100)
          // Auto-attacks use 5% base crit chance
          const baseCritChance = 5;
          const increasedCritChance = char.baseStats?.criticalStrikeChance || 0;
          const finalCritChance = calculateCriticalStrikeChance(baseCritChance, increasedCritChance);
          const isCrit = Math.random() < (finalCritChance / 100);
          const roleDmg = 70;
          const baseDamage = Math.floor(roleDmg * (1 + strength / 150) * (bloodlustActive ? 1.3 : 1));
          const finalDamage = isCrit ? Math.floor(baseDamage * 1.5) : baseDamage;
          
          bossHealth = Math.max(0, bossHealth - finalDamage);
          member.totalDamage = (member.totalDamage || 0) + finalDamage;
          member.damageBySpell = member.damageBySpell || {};
          member.damageBySpell['Shield Slam'] = (member.damageBySpell['Shield Slam'] || 0) + finalDamage;
          if (isCrit) setScreenShake(prev => prev + 1);
          member.gcdEndTime = Date.now() + 1500;
          
          updateCombatState(prev => ({ 
            ...prev, 
            combatLog: [...prev.combatLog, { 
              timestamp: totalTime, 
              type: 'damage', 
              source: char.name, 
              target: boss.enemy.name, 
              value: finalDamage, 
              message: `üõ°Ô∏è Shield Slam ${char.name} hits ${boss.enemy.name} for ${finalDamage}${isCrit ? ' CRIT!' : ''}!` 
            }] 
          }));
          return;
        }
        
        // Healer auto-attack (if not healing)
        const autoGcdReady = !member.gcdEndTime || Date.now() >= member.gcdEndTime;
        if (!autoGcdReady) return;
        
        // PoE: Damage scales with strength, crit chance is separate stat
        const strength = char.baseStats?.strength || 20;
        // PoE-style crit: base crit chance * (1 + increased crit chance / 100)
        // Auto-attacks use 5% base crit chance
        const baseCritChance = 5;
        const increasedCritChance = char.baseStats?.criticalStrikeChance || 0;
        const finalCritChance = calculateCriticalStrikeChance(baseCritChance, increasedCritChance);
        const isCrit = Math.random() < (finalCritChance / 100);
        const roleDmg = 25;
        const baseDamage = Math.floor(roleDmg * (1 + strength / 150) * (bloodlustActive ? 1.3 : 1));
        const finalDamage = isCrit ? Math.floor(baseDamage * 1.5) : baseDamage;
        
        bossHealth = Math.max(0, bossHealth - finalDamage);
        member.totalDamage = (member.totalDamage || 0) + finalDamage;
        member.damageBySpell = member.damageBySpell || {};
        member.damageBySpell['Smite'] = (member.damageBySpell['Smite'] || 0) + finalDamage;
        if (isCrit) setScreenShake(prev => prev + 1);
        member.gcdEndTime = Date.now() + 1500;
        
        updateCombatState(prev => ({ 
          ...prev, 
          combatLog: [...prev.combatLog, { 
            timestamp: totalTime, 
            type: 'damage', 
            source: char.name, 
            target: boss.enemy.name, 
            value: finalDamage, 
            message: `‚ú® Smite ${char.name} hits ${boss.enemy.name} for ${finalDamage}${isCrit ? ' CRIT!' : ''}!` 
          }] 
        }));
      });
      
      const healthPercent = (bossHealth / bossEnemy.maxHealth) * 100;
      if (phase === 1 && healthPercent <= 60) {
        phase = 2;
        updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: boss.enemy.name, target: '', message: `‚ö° ${boss.enemy.name} enters Phase 2!` }] }));
      } else if (phase === 2 && healthPercent <= 30) {
        phase = 3;
        updateCombatState(prev => ({ ...prev, combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: boss.enemy.name, target: '', message: `üí• ${boss.enemy.name} ENRAGES!` }] }));
      }

      // Update boss enemy state for UI (show casting state)
      const bossEnemyState: AnimatedEnemy = {
        ...bossEnemy,
        health: bossHealth,
        isCasting: bossVolleyCasting,
        castProgress: bossVolleyCasting ? ((Date.now() - bossVolleyCastStartTime) / (BOSS_VOLLEY_CAST_TIME * 1000)) * 100 : 0,
        castStartTime: bossVolleyCastStartTime,
        castTotalTime: bossVolleyCasting ? BOSS_VOLLEY_CAST_TIME : undefined
      };
      
      updateCombatState(prev => ({ ...prev, enemies: [bossEnemyState], teamStates: [...teamStates], abilities: [...abilities], bloodlustActive, bloodlustTimer, timeElapsed: totalTime }));
    }

    if (bossHealth <= 0 && !experienceAwarded.has('final_boss')) {
      experienceAwarded.add('final_boss');
      
      // Award experience for boss kill (calculated per character based on their level)
      const aliveTeamMembers = teamStates.filter(m => !m.isDead);
      aliveTeamMembers.forEach(member => {
        const character = team.find(c => c.id === member.id);
        if (character) {
          // Calculate experience based on this character's level (for level difference penalty)
          const bossExp = calculateExperienceFromEnemy(boss.enemy, selectedKeyLevel, scaling.healthMultiplier, character.level);
          
          const levelUpResult = awardExperience(character.id, bossExp);
          if (levelUpResult && levelUpResult.leveledUp) {
            // Add level up animation to state (will be displayed on character frame)
            updateCombatState(prev => ({ 
              ...prev, 
              levelUpAnimations: [...prev.levelUpAnimations, {
                characterId: character.id,
                newLevel: levelUpResult.newLevel,
                timestamp: Date.now()
              }],
              combatLog: [...prev.combatLog, { 
                timestamp: totalTime, 
                type: 'level', 
                source: character.name, 
                target: '', 
                message: `üéâ ${character.name} reached level ${levelUpResult.newLevel}!` 
              }] 
            }));
          }
        }
      });
      
      updateCombatState(prev => ({ 
        ...prev, 
        combatLog: [...prev.combatLog, { 
          timestamp: totalTime, 
          type: 'death', 
          source: '', 
          target: boss.enemy.name, 
          message: `üéâ ${boss.enemy.name} DEFEATED!` 
        }] 
      }));
    }
  }

  // Check for wipe (not timeout) - still give some loot based on progress
  if (!teamStates.some(m => !m.isDead) && !timedOut) {
    updateCombatState(prev => ({ ...prev, phase: 'defeat', combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: 'üíÄ WIPE! Your party has been defeated.' }] }));
    
    // Find what killed teammates - look for recent damage entries targeting team members
    const teamMemberNames = teamStates.map(m => m.name);
    const deathCauses: Record<string, string> = {};
    const recentDamage = currentCombatState.combatLog
      .filter(entry => entry.type === 'damage' && teamMemberNames.includes(entry.target))
      .slice(-20); // Last 20 damage entries
    
    teamStates.forEach(member => {
      if (member.isDead) {
        // Find the last damage entry for this member
        const lastDamage = recentDamage
          .filter(entry => entry.target === member.name)
          .sort((a, b) => b.timestamp - a.timestamp)[0];
        if (lastDamage) {
          deathCauses[member.name] = lastDamage.source || 'Unknown';
        }
      }
    });
    
    // Generate reduced loot for wipe (scales with key level and progress made)
    const progressPercent = totalForcesCleared / dungeon.requiredForces;
    const wipeLootCount = Math.max(1, Math.floor(progressPercent * 3) + Math.floor(selectedKeyLevel / 5));
    const loot = generateDungeonLoot(selectedKeyLevel, false, 0).slice(0, wipeLootCount);
    const orbDrops = generateOrbDrops(selectedKeyLevel, false, progressPercent);
    const xp = Math.floor(200 * scaling.rewardMultiplier * progressPercent);
    
    const result: DungeonRunResult = {
      success: false, keyLevel: selectedKeyLevel, timeElapsed: totalTime, timeLimit: dungeon.timeLimitSeconds,
      upgradeLevel: 0, loot, orbDrops, experienceGained: xp, deaths: teamStates.filter(m => m.isDead).length,
      forcesCleared: totalForcesCleared, forcesRequired: dungeon.requiredForces, combatLog: currentCombatState.combatLog,
      failReason: 'wipe',
      failedPullIndex: currentCombatState.currentPullIndex,
      deathCauses
    };
    
    addOrbs(orbDrops);
    setRunResult(result);
    setIsRunning(false);
    return result;
  }

  // Check for timeout - still give loot but no key upgrade
  if (timedOut) {
    const loot = generateDungeonLoot(selectedKeyLevel, true, 0, scaling.itemQuantity, scaling.itemRarity);
    const orbDrops = generateOrbDrops(selectedKeyLevel, true);
    const xp = Math.floor(500 * scaling.rewardMultiplier);
    
    const result: DungeonRunResult = {
      success: false, keyLevel: selectedKeyLevel, timeElapsed: totalTime, timeLimit: dungeon.timeLimitSeconds,
      upgradeLevel: 0, loot, orbDrops, experienceGained: xp, deaths: teamStates.filter(m => m.isDead).length,
      forcesCleared: totalForcesCleared, forcesRequired: dungeon.requiredForces, combatLog: currentCombatState.combatLog,
      failReason: 'timeout',
      failedPullIndex: currentCombatState.currentPullIndex
    };
    
    addOrbs(orbDrops);
    setRunResult(result);
    setIsRunning(false);
    return result;
  }

  updateCombatState(prev => ({ ...prev, phase: 'victory', enemies: [], combatLog: [...prev.combatLog, { timestamp: totalTime, type: 'phase', source: '', target: '', message: `üèÜ DUNGEON COMPLETE in ${Math.floor(totalTime)}s!` }] }));

  await sleep(500);

  // Calculate upgrade level based on time remaining
  const timeRemaining = dungeon.timeLimitSeconds - totalTime;
  const upgradeLevel = timeRemaining > dungeon.timeLimitSeconds * 0.4 ? 3 : timeRemaining > dungeon.timeLimitSeconds * 0.2 ? 2 : 1;
  
  const loot = generateDungeonLoot(selectedKeyLevel, true, upgradeLevel, scaling.itemQuantity, scaling.itemRarity);
  const orbDrops = generateOrbDrops(selectedKeyLevel, true);
  const xp = Math.floor(1000 * scaling.rewardMultiplier * (1 + upgradeLevel * 0.25));

  const result: DungeonRunResult = {
    success: true, keyLevel: selectedKeyLevel, timeElapsed: totalTime, timeLimit: dungeon.timeLimitSeconds,
    upgradeLevel, loot, orbDrops, experienceGained: xp, deaths: teamStates.filter(m => m.isDead).length,
    forcesCleared: totalForcesCleared, forcesRequired: dungeon.requiredForces, combatLog: currentCombatState.combatLog
  };

  completeDungeonRun(result);
  addOrbs(orbDrops);
  addKey({ id: crypto.randomUUID(), dungeonId: dungeon.id, level: selectedKeyLevel + upgradeLevel, affixes: [], depleted: false });

  setRunResult(result);
  setIsRunning(false);
  return result;

